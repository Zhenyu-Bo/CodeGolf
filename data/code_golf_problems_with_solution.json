[
  {
    "id": "12-days-of-christmas",
    "description": "Print the lyrics to the song The 12 Days of Christmas:\nOn the First day of Christmas\nMy true love sent to me\nA Partridge in a Pear Tree.\n…\nOn the Twelfth day of Christmas\nMy true love sent to me\nTwelve Drummers Drumming,\nEleven Pipers Piping,\nTen Lords-a-Leaping,\nNine Ladies Dancing,\nEight Maids-a-Milking,\nSeven Swans-a-Swimming,\nSix Geese-a-Laying,\nFive Gold Rings,\nFour Calling Birds,\nThree French Hens,\nTwo Turtle Doves, and\nA Partridge in a Pear Tree.",
    "solution": "def sing_12_days_of_christmas():\n    \"\"\"Prints the lyrics to the song The 12 Days of Christmas.\"\"\"\n\n    days = [\n        \"First\", \"Second\", \"Third\", \"Fourth\", \"Fifth\", \"Sixth\",\n        \"Seventh\", \"Eighth\", \"Ninth\", \"Tenth\", \"Eleventh\", \"Twelfth\"\n    ]\n\n    gifts = [\n        \"A Partridge in a Pear Tree.\",\n        \"Two Turtle Doves, and\",\n        \"Three French Hens,\",\n        \"Four Calling Birds,\",\n        \"Five Gold Rings,\",\n        \"Six Geese-a-Laying,\",\n        \"Seven Swans-a-Swimming,\",\n        \"Eight Maids-a-Milking,\",\n        \"Nine Ladies Dancing,\",\n        \"Ten Lords-a-Leaping,\",\n        \"Eleven Pipers Piping,\",\n        \"Twelve Drummers Drumming,\"\n    ]\n\n    for i in range(12):\n        print(f\"On the {days[i]} day of Christmas\")\n        print(\"My true love sent to me\")\n        for j in range(i, -1, -1):\n            print(gifts[j])\n        print()\n\nif __name__ == \"__main__\":\n    sing_12_days_of_christmas()"
  },
  {
    "id": "24-game",
    "description": "The 24 game is an arithmetical puzzle in which the objective is to find a\nway to combine four integers using only basic arithmetic operations\n(+, -, ×, ÷) to get a result of 24. Each integer must be used exactly once.\nThe variation we use is played with a standard 52-card deck, with integers\nranging from 1 to 13. Print all solvable quadruples of integers. The\nintegers of each quadruple should be printed in non-decreasing order.\nKeep in mind that some solutions involve fractions. For example, the only\nsolution to 1 3 4 6 is 6/(1-3/4).\nRosetta Code,\nRosetta Code (2),\nWikipedia\nCopy Answer\nCopied",
    "solution": "from itertools import combinations_with_replacement, combinations\nfrom fractions import Fraction\n\ndef solve_24_game():\n    solvable = set()\n    ops = [lambda a, b: a + b, \n           lambda a, b: a - b, \n           lambda a, b: b - a,\n           lambda a, b: a * b,\n           lambda a, b: a / b if b != 0 else None,\n           lambda a, b: b / a if a != 0 else None]\n    \n    for quad in combinations_with_replacement(range(1, 14), 4):\n        nums = [Fraction(n) for n in quad]\n        if can_make_24(nums, ops):\n            solvable.add(quad)\n    \n    for quad in sorted(solvable):\n        print(' '.join(map(str, quad)))\n\ndef can_make_24(nums, ops, remaining=None):\n    if remaining is None:\n        remaining = set(range(4))\n    \n    if len(remaining) == 1:\n        idx = next(iter(remaining))\n        return abs(float(nums[idx]) - 24) < 1e-6\n    \n    for i, j in combinations(remaining, 2):\n        new_remaining = remaining - {i, j}\n        for op in ops:\n            try:\n                res = op(nums[i], nums[j])\n                if res is None:  # division by zero\n                    continue\n                new_nums = nums.copy()\n                new_nums[i] = res\n                if can_make_24(new_nums, ops, new_remaining | {i}):\n                    return True\n            except ZeroDivisionError:\n                continue\n    return False\n\nif __name__ == \"__main__\":\n    solve_24_game()"
  },
  {
    "id": "99-bottles-of-beer",
    "description": "Print the lyrics to the song 99 Bottles of Beer:\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n…\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def ninety_nine_bottles():\n    for i in range(99, 0, -1):\n        bottles = lambda n: f\"{n} bottle{'s'[:n!=1]} of beer\"\n        print(f\"{bottles(i)} on the wall, {bottles(i)}.\")\n        print(f\"Take one down and pass it around, {bottles(i-1) if i > 1 else 'no more bottles of beer'} on the wall.\\n\")\n    print(\"No more bottles of beer on the wall, no more bottles of beer.\")\n    print(\"Go to the store and buy some more, 99 bottles of beer on the wall.\")\n\nninety_nine_bottles()"
  },
  {
    "id": "abundant-numbers",
    "description": "An abundant number is a number for which the sum of its proper divisors\n(divisors not including the number itself) is greater than the number\nitself. For example 12 is abundant because its proper divisors are\n1, 2, 3, 4, and 6 which add up to\n16.\nPrint all the abundant numbers from 1 to\n200\ninclusive, each on their own line.\nVariants:\nAbundant Numbers (Long)\nOEIS A005101,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_abundant(n):\n    \"\"\"\n    检查一个数是否为盈数。\n\n    Args:\n        n: 要检查的整数。\n\n    Returns:\n        如果 n 是盈数，则返回 True，否则返回 False。\n    \"\"\"\n    if n <= 1:\n        return False\n\n    sum_of_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_of_divisors += i\n            if i * i != n:\n                sum_of_divisors += n // i\n\n    return sum_of_divisors > n\n\n\ndef find_abundant_numbers(limit):\n    \"\"\"\n    找到从 1 到 limit（包括 limit）的所有盈数。\n\n    Args:\n        limit: 搜索范围的上限。\n\n    Returns:\n        一个包含盈数的列表。\n    \"\"\"\n    abundant_numbers = []\n    for i in range(1, limit + 1):\n        if is_abundant(i):\n            abundant_numbers.append(i)\n    return abundant_numbers\n\n\nif __name__ == \"__main__\":\n    abundant_numbers = find_abundant_numbers(200)\n    for number in abundant_numbers:\n        print(number)"
  },
  {
    "id": "abundant-numbers-long",
    "description": "An abundant number is a number for which the sum of its proper divisors\n(divisors not including the number itself) is greater than the number\nitself. For example 12 is abundant because its proper divisors are\n1, 2, 3, 4, and 6 which add up to\n16.\nPrint all the abundant numbers from 1 to\n1,000\ninclusive, each on their own line.\nVariants:\nAbundant Numbers\nOEIS A005101,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_abundant(n):\n    \"\"\"\n    Checks if a number is abundant.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if the number is abundant, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n\n    divisor_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            if i * i != n:\n                divisor_sum += n // i\n\n    return divisor_sum > n\n\n\ndef find_abundant_numbers(limit):\n    \"\"\"\n    Finds all abundant numbers up to a given limit.\n\n    Args:\n        limit: The upper limit to search for abundant numbers.\n\n    Returns:\n        A list of abundant numbers.\n    \"\"\"\n    abundant_numbers = []\n    for i in range(1, limit + 1):\n        if is_abundant(i):\n            abundant_numbers.append(i)\n    return abundant_numbers\n\n\nif __name__ == \"__main__\":\n    abundant_numbers = find_abundant_numbers(1000)\n    for number in abundant_numbers:\n        print(number)"
  },
  {
    "id": "arabic-to-roman",
    "description": "For each numeric argument in Arabic numerals, print the same number in\nRoman numerals.\nThe numbers range from 1 to 3999 inclusive.\nArabic\n1\n5\n10\n50\n100\n500\n1000\nRoman\nI\nV\nX\nL\nC\nD\nM\nVariants:\nRoman to Arabic\nRosetta Code,\nWikipedia",
    "solution": "def to_roman(num):\n    roman_map = [\n        (1000, 'M'),\n        (900, 'CM'),\n        (500, 'D'),\n        (400, 'CD'),\n        (100, 'C'),\n        (90, 'XC'),\n        (50, 'L'),\n        (40, 'XL'),\n        (10, 'X'),\n        (9, 'IX'),\n        (5, 'V'),\n        (4, 'IV'),\n        (1, 'I')\n    ]\n    result = []\n    for value, symbol in roman_map:\n        while num >= value:\n            result.append(symbol)\n            num -= value\n    return ''.join(result)\n\nimport sys\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        sys.exit(1)\n    for arg in sys.argv[1:]:\n        try:\n            num = int(arg)\n            if 1 <= num <= 3999:\n                print(to_roman(num))\n            else:\n                print(f\"Error: {num} is out of range (1-3999)\")\n        except ValueError:\n            print(f\"Error: '{arg}' is not a valid integer\")"
  },
  {
    "id": "arithmetic-numbers",
    "description": "An arithmetic number is a number for which the average of its divisors is\nan integer. For example, number 6 is arithmetic because its divisors\n(1, 2, 3, and 6) average 3.\nPrint all the arithmetic numbers from 1 to 10,000 inclusive,\neach on their own line.\nOEIS A003601,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_arithmetic_number(n):\n  \"\"\"\n  检查一个数是否是算术数。\n\n  Args:\n    n: 要检查的整数。\n\n  Returns:\n    如果 n 是算术数，则返回 True，否则返回 False。\n  \"\"\"\n  divisors = []\n  for i in range(1, n + 1):\n    if n % i == 0:\n      divisors.append(i)\n\n  if not divisors: # n = 0\n    return False\n\n  average = sum(divisors) / len(divisors)\n  return average == int(average)\n\n\ndef find_arithmetic_numbers(limit):\n  \"\"\"\n  找出直到 limit 的所有算术数。\n\n  Args:\n    limit: 要搜索的上限（包括）。\n\n  Returns:\n    一个包含所有直到 limit 的算术数的列表。\n  \"\"\"\n  arithmetic_numbers = []\n  for i in range(1, limit + 1):\n    if is_arithmetic_number(i):\n      arithmetic_numbers.append(i)\n  return arithmetic_numbers\n\n\nif __name__ == \"__main__\":\n  arithmetic_numbers = find_arithmetic_numbers(10000)\n  for number in arithmetic_numbers:\n    print(number)"
  },
  {
    "id": "arrows",
    "description": "Starting at [0, 0] print the cumulative result of applying each of\nthe given Unicode arrow arguments. The arrows will be a random combination\nof these:\nCoordArrows\n[-1, -1]\n↙ U+2199,\n↲ U+21B2,\n⇙ U+21D9\n[-1,  0]\n← U+2190,\n⇐ U+21D0,\n⇦ U+21E6\n[-1,  1]\n↖ U+2196,\n↰ U+21B0,\n⇖ U+21D6\n[ 0, -1]\n↓ U+2193,\n⇓ U+21D3,\n⇩ U+21E9\n[ 0,  0]\n↔ U+2194,\n↕ U+2195,\n⇔ U+21D4,\n⇕ U+21D5,\n⥀ U+2940,\n⥁ U+2941\n[ 0,  1]\n↑ U+2191,\n⇑ U+21D1,\n⇧ U+21E7\n[ 1, -1]\n↘ U+2198,\n↳ U+21B3,\n⇘ U+21D8\n[ 1,  0]\n→ U+2192,\n⇒ U+21D2,\n⇨ U+21E8\n[ 1,  1]\n↗ U+2197,\n↱ U+21B1,\n⇗ U+21D7\nCopy as JSON\nCopied",
    "solution": "def main():\n    import sys\n    arrow_map = {'↙': (-1, -1), '↲': (-1, -1), '⇙': (-1, -1), '←': (-1, 0), '⇐': (-1, 0), '⇦': (-1, 0), '↖': (-1, 1), '↰': (-1, 1), '⇖': (-1, 1), '↓': (0, -1), '⇓': (0, -1), '⇩': (0, -1), '↔': (0, 0), '↕': (0, 0), '⇔': (0, 0), '⇕': (0, 0), '⥀': (0, 0), '⥁': (0, 0), '↑': (0, 1), '⇑': (0, 1), '⇧': (0, 1), '↘': (1, -1), '↳': (1, -1), '⇘': (1, -1), '→': (1, 0), '⇒': (1, 0), '⇨': (1, 0), '↗': (1, 1), '↱': (1, 1), '⇗': (1, 1)}\n    x, y = 0, 0\n    if len(sys.argv) > 1:\n        input_str = ''.join(sys.argv[1:])\n        for char in input_str:\n            if char in arrow_map:\n                dx, dy = arrow_map[char]\n                x += dx\n                y += dy\n                print(f\"{x} {y}\")\n    else:\n        print(\"请提供Unicode箭头作为参数\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "ascending-primes",
    "description": "Print all primes whose decimal digits are distinct and appear in ascending\norder. There are 100 such primes, the largest being 23456789.\nOEIS A052015\nCopy Answer\nCopied",
    "solution": "def is_prime(n):\n    if n < 2: return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0: return False\n    return True\n\ndef find_ascending_primes():\n    from itertools import combinations\n    primes = []\n    for length in range(1, 9):\n        for digits in combinations('123456789', length):\n            num = int(''.join(digits))\n            if is_prime(num): primes.append(num)\n    return primes\n\nascending_primes = find_ascending_primes()\nfor prime in ascending_primes: print(prime)"
  },
  {
    "id": "ascii-table",
    "description": "Print the following hex ASCII table, taken from man 7 ascii.\n2 3 4 5 6 7\n-------------\n0:   0 @ P ` p\n1: ! 1 A Q a q\n2: \" 2 B R b r\n3: # 3 C S c s\n4: $ 4 D T d t\n5: % 5 E U e u\n6: & 6 F V f v\n7: ' 7 G W g w\n8: ( 8 H X h x\n9: ) 9 I Y i y\nA: * : J Z j z\nB: + ; K [ k {\nC: , < L \\ l |\nD: - = M ] m }\nE: . > N ^ n ~\nF: / ? O _ o DEL\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def print_ascii_table():\n    \"\"\"Prints a hex ASCII table as described in the prompt.\"\"\"\n\n    print(\"   2 3 4 5 6 7\")\n    print(\" -------------\")\n    for i in range(16):\n        hex_val = hex(i)[2:].upper()  # Convert to hex and uppercase\n\n        char_0 = chr(i + 0x20)  # Column 2 (0x20 to 0x2F)\n        char_1 = chr(i + 0x30)  # Column 3 (0x30 to 0x3F)\n        char_2 = chr(i + 0x40)  # Column 4 (0x40 to 0x4F)\n        char_3 = chr(i + 0x50)  # Column 5 (0x50 to 0x5F)\n        char_4 = chr(i + 0x60)  # Column 6 (0x60 to 0x6F)\n        char_5 = chr(i + 0x70)  # Column 7 (0x70 to 0x7F)\n\n        if i == 15:\n            char_5 = \"DEL\"\n        print(f\"{hex_val}: {char_0} {char_1} {char_2} {char_3} {char_4} {char_5}\")\n\nif __name__ == \"__main__\":\n    print_ascii_table()"
  },
  {
    "id": "billiards",
    "description": "Given the size of a billiard table, draw the path of a ball shot from the\ntop left corner of the table at 45 degree angles to the sides.\nFor example, given 4 14, output\n\\  /\\  /\\  /\\\n\\/  \\/  \\/  \\\n/\\  /\\  /\\  /\n/  \\/  \\/  \\/\nSeparate each size with empty lines.",
    "solution": "import sys\ndef draw_billiard_path(h,w):\n table=[[' 'for _ in range(w)]for _ in range(h)]\n x,y,dx,dy=0,0,1,1\n while True:\n  table[y][x]='\\\\'if dx==dy else '/'\n  x+=dx;y+=dy\n  if x==w:x=w-1;dx*=-1\n  elif x<0:x=0;dx*=-1\n  if y==h:y=h-1;dy*=-1\n  elif y<0:y=0;dy*=-1\n  if x==0 and y==0 and dx==1 and dy==1:break\n for row in table:print(''.join(row))\n print()\nraw_args=sys.argv[1:]\nflattened=[]\nfor arg in raw_args:flattened.extend(arg.strip().split())\nif len(flattened)%2!=0:sys.exit(1)\nfor i in range(0,len(flattened),2):\n h,w=int(flattened[i]),int(flattened[i+1])\n draw_billiard_path(h,w)"
  },
  {
    "id": "brainfuck",
    "description": "Brainfuck is a minimalistic esoteric programming language created by\nUrban Müller in 1993.\nAssuming an infinitely large array, the entire brainfuck alphabet matches\nthe following pseudocode:\nCmd\nPseudocode\n>\nptr++\n<\nptr--\n+\narray[ptr]++\n-\narray[ptr]--\n.\nprint(chr(array[ptr]))\n[\nwhile(array[ptr]){\n]\n}\nWrite a program that will receive various brainfuck programs as arguments\nand execute each program in turn.\nArguments will not contain any character not listed in the table above.\nIn particular, the input command \",\" is not tested.\nRosetta Code,\nWikipedia",
    "solution": "def brainfuck_interpreter(program):\n    \"\"\"\n    Interprets a Brainfuck program.\n\n    Args:\n        program: The Brainfuck program string.\n\n    Returns:\n        The output string of the program.\n    \"\"\"\n\n    array_size = 30000  # Simulate an infinitely large array with a large size\n    array = [0] * array_size\n    ptr = 0\n    output = \"\"\n    loop_stack = []\n    program_counter = 0\n\n    while program_counter < len(program):\n        instruction = program[program_counter]\n\n        if instruction == '>':\n            ptr = (ptr + 1) % array_size  # Wrap around\n        elif instruction == '<':\n            ptr = (ptr - 1) % array_size  # Wrap around\n        elif instruction == '+':\n            array[ptr] = (array[ptr] + 1) % 256  # Wrap around at 256\n        elif instruction == '-':\n            array[ptr] = (array[ptr] - 1) % 256  # Wrap around at 256\n        elif instruction == '.':\n            output += chr(array[ptr])\n        elif instruction == '[':\n            if array[ptr] == 0:\n                # Find the matching ']'\n                loop_count = 1\n                temp_counter = program_counter + 1\n                while temp_counter < len(program):\n                    if program[temp_counter] == '[':\n                        loop_count += 1\n                    elif program[temp_counter] == ']':\n                        loop_count -= 1\n                        if loop_count == 0:\n                            program_counter = temp_counter\n                            break\n                    temp_counter += 1\n                else:\n                    raise ValueError(\"Unmatched '['\")  # Handle unmatched '['\n            else:\n                loop_stack.append(program_counter)\n        elif instruction == ']':\n            if array[ptr] != 0:\n                program_counter = loop_stack[-1]\n            else:\n                loop_stack.pop()\n        \n        program_counter += 1\n\n    return output\n\nif __name__ == '__main__':\n    import sys\n\n    if len(sys.argv) > 1:\n        for i in range(1, len(sys.argv)):\n            program = sys.argv[i]\n            try:\n                output = brainfuck_interpreter(program)\n                print(output, end=\"\")  # Print the output without extra newline\n            except ValueError as e:\n                print(f\"Error: {e}\")\n    else:\n        print(\"No Brainfuck program provided as argument.\")"
  },
  {
    "id": "card-number-validation",
    "description": "The Luhn algorithm is a simple check digit formula used to validate a\nvariety of identification numbers.\nGiven a list of 16-digit payment card numbers\n(like 3566 0020 2036 0505), output the ones that are valid\naccording to the Luhn algorithm. The digits of each input are separated\ninto groups of four by spaces.\nTo verify a 16-digit card number like XyXy XyXy XyXy XyXy,\nadd up all the \"y\" digits and the digit sums of the\ndoubles of the \"X\" digits. The card number is valid if\nthis sum is divisible by 10.\nRosetta Code,\nWikipedia",
    "solution": "import sys\nfor card in sys.argv[1:]:\n d=card.replace(' ','')\n if len(d)==16 and d.isdigit():\n  s=0\n  for i,c in enumerate(d):\n   n=int(c)\n   if i%2==0:\n    n*=2\n    if n>9:n-=9\n   s+=n\n  if s%10==0:print(card)"
  },
  {
    "id": "catalan-numbers",
    "description": "The nth Catalan number can be expressed as C(n) = binomial(2n,n)/(n+1).\nThey are unrelated to Catalan’s Constant\nexcept by name.\nPrint the first 100 Catalan numbers, from C(0) to\nC(99) inclusive, each on their own line.\nNote: C(99) is 57 digits long, and is greater than 2187.\nOEIS A000108,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import math\n\ndef catalan(n):\n    \"\"\"\n    Calculates the nth Catalan number.\n    \"\"\"\n    if n < 0:\n        return 0\n    numerator = math.factorial(2 * n)\n    denominator = math.factorial(n) * math.factorial(n) * (n + 1)\n    return numerator // denominator\n\ndef main():\n    \"\"\"\n    Prints the first 100 Catalan numbers.\n    \"\"\"\n    for n in range(100):\n        print(catalan(n))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "catalans-constant",
    "description": "Catalan’s constant is a mathematical constant equal to\n1/1 − 1/3² + 1/5² − 1/7² + 1/9² − …\nIt is unrelated to the Catalan Numbers except\nby name.\nPrint the first 1,000 decimal digits of Catalan’s constant.\nOEIS A006752,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal,getcontext\ngetcontext().prec=1010\ndef arctan(x):\n total=Decimal(0)\n term=x\n n=0\n threshold=Decimal(10)**(-1010)\n while abs(term)>threshold:\n  total+=term\n  n+=1\n  term=term*(-x*x)*(2*n-1)/(2*n+1)\n return total\nx1=Decimal(1)/5\nx2=Decimal(1)/239\npi_val=16*arctan(x1)-4*arctan(x2)\nsqrt3=Decimal(3).sqrt()\nx_val=2+sqrt3\nln_val=x_val.ln()\nS=Decimal(0)\na=Decimal(1)\nS+=a\nfor k in range(1,1701):\n k_dec=Decimal(k)\n numerator=k_dec*(2*k_dec-1)\n denominator=2*(2*k_dec+1)**2\n a=a*numerator/denominator\n S+=a\nterm1=(pi_val/8)*ln_val\nterm2=(Decimal(3)/8)*S\nG_val=term1+term2\ns=format(G_val,'.1000f')\nprint(s)"
  },
  {
    "id": "christmas-trees",
    "description": "Draw a size ascending range of Christmas trees using asterisks, ranging from size 3 to size 9, each tree separated by a blank line.\n\nA size 3 tree should look like this, with a single centered asterisk for the trunk:\n\n   *\n  ***\n *****\n   *\nWith the largest size 9 tree looking like this:\n\n         *\n        ***\n       *****\n      *******\n     *********\n    ***********\n   *************\n  ***************\n *****************\n         *",
    "solution": "def print_tree(size):\n width=2*size-1\n for i in range(size):\n  stars='*'*(2*i+1)\n  print(' '+stars.center(width))\n print(' '+'*'.center(width))\nfor s in range(3,10):\n print_tree(s)\n print()"
  },
  {
    "id": "collatz",
    "description": "The Collatz conjecture states that, for any positive integer n, it\nwill eventually reach 1 by repeatedly applying the following procedure:\nIf n is even, divide it by 2.\nIf n is odd, multiply by 3 and then add 1.\nThe number of steps needed for n to reach 1 is called its stopping\ntime. For example, the stopping time of 10 is six:\n10 → 5 → 16 → 8 → 4 → 2 → 1\nPrint the stopping times of all the numbers from 1 to 1,000\ninclusive, each on their own line.\nOEIS A006577,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def collatz_stopping_time(n):\n  \"\"\"\n  Calculates the stopping time of a number n according to the Collatz conjecture.\n\n  Args:\n    n: A positive integer.\n\n  Returns:\n    The number of steps it takes for n to reach 1.\n  \"\"\"\n  if n <= 0:\n    raise ValueError(\"Input must be a positive integer.\")\n\n  steps = 0\n  while n != 1:\n    if n % 2 == 0:\n      n = n // 2  # Integer division\n    else:\n      n = 3 * n + 1\n    steps += 1\n  return steps\n\n\nif __name__ == \"__main__\":\n  for i in range(1, 1001):\n    stopping_time = collatz_stopping_time(i)\n    print(stopping_time)"
  },
  {
    "id": "css-colors",
    "description": "Given a list of all the CSS color keywords print the hex values in the\ncorresponding order. The full mapping is as follows:\nKeywordHex\nIndianRed\n#cd5c5c\nLightCoral\n#f08080\nSalmon\n#fa8072\nDarkSalmon\n#e9967a\nLightSalmon\n#ffa07a\nRed\n#ff0000\nCrimson\n#dc143c\nFireBrick\n#b22222\nDarkRed\n#8b0000\nPink\n#ffc0cb\nLightPink\n#ffb6c1\nHotPink\n#ff69b4\nDeepPink\n#ff1493\nMediumVioletRed\n#c71585\nPaleVioletRed\n#db7093\nCoral\n#ff7f50\nTomato\n#ff6347\nOrangeRed\n#ff4500\nDarkOrange\n#ff8c00\nOrange\n#ffa500\nGold\n#ffd700\nYellow\n#ffff00\nLightYellow\n#ffffe0\nLemonChiffon\n#fffacd\nLightGoldenRodYellow\n#fafad2\nPapayaWhip\n#ffefd5\nMoccasin\n#ffe4b5\nPeachPuff\n#ffdab9\nPaleGoldenRod\n#eee8aa\nKhaki\n#f0e68c\nDarkKhaki\n#bdb76b\nLavender\n#e6e6fa\nThistle\n#d8bfd8\nPlum\n#dda0dd\nViolet\n#ee82ee\nOrchid\n#da70d6\nFuchsia\n#ff00ff\nKeywordHex\nMagenta\n#ff00ff\nMediumOrchid\n#ba55d3\nMediumPurple\n#9370db\nBlueViolet\n#8a2be2\nDarkViolet\n#9400d3\nDarkOrchid\n#9932cc\nDarkMagenta\n#8b008b\nPurple\n#800080\nIndigo\n#4b0082\nDarkSlateBlue\n#483d8b\nSlateBlue\n#6a5acd\nMediumSlateBlue\n#7b68ee\nRebeccaPurple\n#663399\nGreenYellow\n#adff2f\nChartreuse\n#7fff00\nLawnGreen\n#7cfc00\nLime\n#00ff00\nLimeGreen\n#32cd32\nPaleGreen\n#98fb98\nLightGreen\n#90ee90\nSpringGreen\n#00ff7f\nMediumSpringGreen\n#00fa9a\nMediumSeaGreen\n#3cb371\nSeaGreen\n#2e8b57\nForestGreen\n#228b22\nGreen\n#008000\nDarkGreen\n#006400\nYellowGreen\n#9acd32\nOliveDrab\n#6b8e23\nOlive\n#808000\nDarkOliveGreen\n#556b2f\nMediumAquamarine\n#66cdaa\nDarkSeaGreen\n#8fbc8f\nLightSeaGreen\n#20b2aa\nDarkCyan\n#008b8b\nTeal\n#008080\nAqua\n#00ffff\nKeywordHex\nCyan\n#00ffff\nLightCyan\n#e0ffff\nPaleTurquoise\n#afeeee\nAquamarine\n#7fffd4\nTurquoise\n#40e0d0\nMediumTurquoise\n#48d1cc\nDarkTurquoise\n#00ced1\nCadetBlue\n#5f9ea0\nSteelBlue\n#4682b4\nLightSteelBlue\n#b0c4de\nPowderBlue\n#b0e0e6\nLightBlue\n#add8e6\nSkyBlue\n#87ceeb\nLightSkyBlue\n#87cefa\nDeepSkyBlue\n#00bfff\nDodgerBlue\n#1e90ff\nCornflowerBlue\n#6495ed\nRoyalBlue\n#4169e1\nBlue\n#0000ff\nMediumBlue\n#0000cd\nDarkBlue\n#00008b\nNavy\n#000080\nMidnightBlue\n#191970\nCornsilk\n#fff8dc\nBlanchedAlmond\n#ffebcd\nBisque\n#ffe4c4\nNavajoWhite\n#ffdead\nWheat\n#f5deb3\nBurlywood\n#deb887\nTan\n#d2b48c\nRosyBrown\n#bc8f8f\nSandyBrown\n#f4a460\nGoldenRod\n#daa520\nDarkGoldenRod\n#b8860b\nPeru\n#cd853f\nChocolate\n#d2691e\nSaddleBrown\n#8b4513\nKeywordHex\nSienna\n#a0522d\nBrown\n#a52a2a\nMaroon\n#800000\nWhite\n#ffffff\nSnow\n#fffafa\nHoneydew\n#f0fff0\nMintCream\n#f5fffa\nAzure\n#f0ffff\nAliceBlue\n#f0f8ff\nGhostWhite\n#f8f8ff\nWhiteSmoke\n#f5f5f5\nSeaShell\n#fff5ee\nBeige\n#f5f5dc\nOldLace\n#fdf5e6\nFloralWhite\n#fffaf0\nIvory\n#fffff0\nAntiqueWhite\n#faebd7\nLinen\n#faf0e6\nLavenderBlush\n#fff0f5\nMistyRose\n#ffe4e1\nGainsboro\n#dcdcdc\nLightGray\n#d3d3d3\nLightGrey\n#d3d3d3\nSilver\n#c0c0c0\nDarkGray\n#a9a9a9\nDarkGrey\n#a9a9a9\nGray\n#808080\nGrey\n#808080\nDimGray\n#696969\nDimGrey\n#696969\nLightSlateGray\n#778899\nLightSlateGrey\n#778899\nSlateGray\n#708090\nSlateGrey\n#708090\nDarkSlateGray\n#2f4f4f\nDarkSlateGrey\n#2f4f4f\nBlack\n#000000\nVariants:\nCSS Colors (Inverse)\nThe output will be checked case-insensitively.\nCopy as JSON\nCopied",
    "solution": "import sys\ncolor_map={\"indianred\":\"#cd5c5c\",\"lightcoral\":\"#f08080\",\"salmon\":\"#fa8072\",\"darksalmon\":\"#e9967a\",\"lightsalmon\":\"#ffa07a\",\"red\":\"#ff0000\",\"crimson\":\"#dc143c\",\"firebrick\":\"#b22222\",\"darkred\":\"#8b0000\",\"pink\":\"#ffc0cb\",\"lightpink\":\"#ffb6c1\",\"hotpink\":\"#ff69b4\",\"deeppink\":\"#ff1493\",\"mediumvioletred\":\"#c71585\",\"palevioletred\":\"#db7093\",\"coral\":\"#ff7f50\",\"tomato\":\"#ff6347\",\"orangered\":\"#ff4500\",\"darkorange\":\"#ff8c00\",\"orange\":\"#ffa500\",\"gold\":\"#ffd700\",\"yellow\":\"#ffff00\",\"lightyellow\":\"#ffffe0\",\"lemonchiffon\":\"#fffacd\",\"lightgoldenrodyellow\":\"#fafad2\",\"papayawhip\":\"#ffefd5\",\"moccasin\":\"#ffe4b5\",\"peachpuff\":\"#ffdab9\",\"palegoldenrod\":\"#eee8aa\",\"khaki\":\"#f0e68c\",\"darkkhaki\":\"#bdb76b\",\"lavender\":\"#e6e6fa\",\"thistle\":\"#d8bfd8\",\"plum\":\"#dda0dd\",\"violet\":\"#ee82ee\",\"orchid\":\"#da70d6\",\"fuchsia\":\"#ff00ff\",\"magenta\":\"#ff00ff\",\"mediumorchid\":\"#ba55d3\",\"mediumpurple\":\"#9370db\",\"blueviolet\":\"#8a2be2\",\"darkviolet\":\"#9400d3\",\"darkorchid\":\"#9932cc\",\"darkmagenta\":\"#8b008b\",\"purple\":\"#800080\",\"indigo\":\"#4b0082\",\"darkslateblue\":\"#483d8b\",\"slateblue\":\"#6a5acd\",\"mediumslateblue\":\"#7b68ee\",\"rebeccapurple\":\"#663399\",\"greenyellow\":\"#adff2f\",\"chartreuse\":\"#7fff00\",\"lawngreen\":\"#7cfc00\",\"lime\":\"#00ff00\",\"limegreen\":\"#32cd32\",\"palegreen\":\"#98fb98\",\"lightgreen\":\"#90ee90\",\"springgreen\":\"#00ff7f\",\"mediumspringgreen\":\"#00fa9a\",\"mediumseagreen\":\"#3cb371\",\"seagreen\":\"#2e8b57\",\"forestgreen\":\"#228b22\",\"green\":\"#008000\",\"darkgreen\":\"#006400\",\"yellowgreen\":\"#9acd32\",\"olivedrab\":\"#6b8e23\",\"olive\":\"#808000\",\"darkolivegreen\":\"#556b2f\",\"mediumaquamarine\":\"#66cdaa\",\"darkseagreen\":\"#8fbc8f\",\"lightseagreen\":\"#20b2aa\",\"darkcyan\":\"#008b8b\",\"teal\":\"#008080\",\"aqua\":\"#00ffff\",\"cyan\":\"#00ffff\",\"lightcyan\":\"#e0ffff\",\"paleturquoise\":\"#afeeee\",\"aquamarine\":\"#7fffd4\",\"turquoise\":\"#40e0d0\",\"mediumturquoise\":\"#48d1cc\",\"darkturquoise\":\"#00ced1\",\"cadetblue\":\"#5f9ea0\",\"steelblue\":\"#4682b4\",\"lightsteelblue\":\"#b0c4de\",\"powderblue\":\"#b0e0e6\",\"lightblue\":\"#add8e6\",\"skyblue\":\"#87ceeb\",\"lightskyblue\":\"#87cefa\",\"deepskyblue\":\"#00bfff\",\"dodgerblue\":\"#1e90ff\",\"cornflowerblue\":\"#6495ed\",\"royalblue\":\"#4169e1\",\"blue\":\"#0000ff\",\"mediumblue\":\"#0000cd\",\"darkblue\":\"#00008b\",\"navy\":\"#000080\",\"midnightblue\":\"#191970\",\"cornsilk\":\"#fff8dc\",\"blanchedalmond\":\"#ffebcd\",\"bisque\":\"#ffe4c4\",\"navajowhite\":\"#ffdead\",\"wheat\":\"#f5deb3\",\"burlywood\":\"#deb887\",\"tan\":\"#d2b48c\",\"rosybrown\":\"#bc8f8f\",\"sandybrown\":\"#f4a460\",\"goldenrod\":\"#daa520\",\"darkgoldenrod\":\"#b8860b\",\"peru\":\"#cd853f\",\"chocolate\":\"#d2691e\",\"saddlebrown\":\"#8b4513\",\"sienna\":\"#a0522d\",\"brown\":\"#a52a2a\",\"maroon\":\"#800000\",\"white\":\"#ffffff\",\"snow\":\"#fffafa\",\"honeydew\":\"#f0fff0\",\"mintcream\":\"#f5fffa\",\"azure\":\"#f0ffff\",\"aliceblue\":\"#f0f8ff\",\"ghostwhite\":\"#f8f8ff\",\"whitesmoke\":\"#f5f5f5\",\"seashell\":\"#fff5ee\",\"beige\":\"#f5f5dc\",\"oldlace\":\"#fdf5e6\",\"floralwhite\":\"#fffaf0\",\"ivory\":\"#fffff0\",\"antiquewhite\":\"#faebd7\",\"linen\":\"#faf0e6\",\"lavenderblush\":\"#fff0f5\",\"mistyrose\":\"#ffe4e1\",\"gainsboro\":\"#dcdcdc\",\"lightgray\":\"#d3d3d3\",\"lightgrey\":\"#d3d3d3\",\"silver\":\"#c0c0c0\",\"darkgray\":\"#a9a9a9\",\"darkgrey\":\"#a9a9a9\",\"gray\":\"#808080\",\"grey\":\"#808080\",\"dimgray\":\"#696969\",\"dimgrey\":\"#696969\",\"lightslategray\":\"#778899\",\"lightslategrey\":\"#778899\",\"slategray\":\"#708090\",\"slategrey\":\"#708090\",\"darkslategray\":\"#2f4f4f\",\"darkslategrey\":\"#2f4f4f\",\"black\":\"#000000\"}\nargs=sys.argv[1:]\nfor name in args:\n key=name.lower()\n print(color_map.get(key,\"Unknown\"))"
  },
  {
    "id": "cubes",
    "description": "Draw 7 cubes in increasing size using \"╱\" (U+2571) for the diagonal\nedges, \"│\" (U+2502) for the vertical edges, \"─\" (U+2500) for the\nhorizontal edges, and \"█\" (U+2588) for the vertices. The cubes should\nrange from size 1 to size 7 with a blank line between each\ncube. A size 1 cube should look like:\n█────█\n╱    ╱│\n█────█ │\n│    │ █\n│    │╱\n█────█\nAnd a size 7 cube should look like:\n█────────────────────────────█\n╱                            ╱│\n╱                            ╱ │\n╱                            ╱  │\n╱                            ╱   │\n╱                            ╱    │\n╱                            ╱     │\n╱                            ╱      │\n█────────────────────────────█       │\n│                            │       │\n│                            │       │\n│                            │       │\n│                            │       │\n│                            │       │\n│                            │       │\n│                            │       █\n│                            │      ╱\n│                            │     ╱\n│                            │    ╱\n│                            │   ╱\n│                            │  ╱\n│                            │ ╱\n│                            │╱\n█────────────────────────────█\nCopy Answer\nCopied",
    "solution": "def draw_cube(n):\n V='█';D='╱';H='─';W='│'\n offset=n+1\n Wd=n*4+2\n lines=[]\n lines.append(' '*offset+V+H*(Wd-2)+V)\n for i in range(1,offset):\n  indent=offset-i\n  lines.append(' '*indent+D+' '*(Wd-2)+D+' '*(i-1)+W)\n lines.append(V+H*(Wd-2)+V+' '*(offset-1)+W)\n for j in range(n):\n  if j<n-1:lines.append(W+' '*(Wd-2)+W+' '*(offset-1)+W)\n  else:lines.append(W+' '*(Wd-2)+W+' '*(offset-1)+V)\n for i in range(1,n+1):\n  lines.append(W+' '*(Wd-2)+W+' '*(offset-1-i)+D)\n lines.append(V+H*(Wd-2)+V)\n return '\\n'.join(lines)\nfor size in range(1,8):\n print(draw_cube(size))\n print()"
  },
  {
    "id": "day-of-week",
    "description": "Given a date in the YYYY-MM-DD format between 1583-01-01 and\n9999-12-31 inclusive, output the English name of the corresponding day\nof the week.\nWikipedia",
    "solution": "import sys;import datetime\ndef parse_and_print(date_str):\n try:\n  date_obj=datetime.datetime.strptime(date_str,'%Y-%m-%d')\n  print(date_obj.strftime('%A'))\n except ValueError:\n  print(f\"{date_str}: Invalid date format (expected YYYY-MM-DD)\")\nfor date_input in sys.argv[1:]:\n parse_and_print(date_input)"
  },
  {
    "id": "dfa-simulator",
    "description": "A deterministic finite automaton or DFA is a\nfinite-state machine that moves between states as it reads characters\nfrom a string.\nEach input consists of a table describing the DFA, and a quoted input\nstring, like so:\na b c d e f\n> 0 0 0 0 1 0 0\n1 0 0 0 1 0 2\n2 3 0 0 1 0 0\nF3 3 3 3 3 3 3\n\"adbacadafad\"\nIn this table, we can find the following information:\nThere are four states, called 0, 1,\n2, and 3.\nStates are always digits 0-9.\nThere may be up to 10 states.\nThere are six characters in the input alphabet: a,\nb, c, d, e, and\nf.\nInput characters may be lowercase letters a-z or\ndigits 0-9.\nThe table entries describe the new state for each (current state,\ncharacter) pair.\nFor example, if the current state is 0, and a\nd is read, the next state is 1.\nThe row describing state 0 is marked with\n> so it is the initial state.\nThere is exactly one initial state.\nThe row describing state 3 is marked with\nF so it is an accept state.\nThere may be multiple accept states, or none at all.\nUse the table to move the DFA between its states by feeding it\ncharacters from the input string.\nIn our example:\nThe initial state is 0. The first character is\na. Looking at the table, we see the new state is\n0.\nThe current state is 0. The next character is\nd. Looking at the table, we see the new state is\n1.\nThe current state is 1. The next character is\nb. Looking at the table, we see the new state is\n0.\n…\nFinally, print the name of the state, followed by a space, followed\nby either Accept (if it is an accept state) or\nReject (otherwise). In this case, we end in state\n1 so we print 1 Reject.\nWikipedia",
    "solution": "import sys\ndef main():\n if len(sys.argv)<2:\n  print(f\"Usage: python {sys.argv[0]} <DFA blocks as args>\",file=sys.stderr)\n  sys.exit(1)\n raw_lines=[]\n for arg in sys.argv[1:]:\n  raw_lines.extend(arg.split('\\n'))\n lines=[ln.rstrip() for ln in raw_lines if ln.strip()]\n idx=0\n while idx<len(lines):\n  alphabet=lines[idx].split()\n  idx+=1\n  transitions={}\n  accept_states=set()\n  initial_state=None\n  while idx<len(lines) and not lines[idx].startswith('\"'):\n   parts=lines[idx].split()\n   first=parts[0]\n   if any(c.isdigit() for c in first):\n    tag=first\n    state=first.lstrip('>F')\n    rest=parts[1:]\n   else:\n    tag=first\n    state=parts[1]\n    rest=parts[2:]\n   if '>' in tag:initial_state=state\n   if 'F' in tag:accept_states.add(state)\n   if len(rest)!=len(alphabet):\n    print(f\"Error: state {state} has {len(rest)} transitions but alphabet size is {len(alphabet)}\",file=sys.stderr)\n    sys.exit(1)\n   transitions[state]=dict(zip(alphabet,rest))\n   idx+=1\n  if initial_state is None:\n   print(\"Error: no initial state specified\",file=sys.stderr)\n   sys.exit(1)\n  if idx>=len(lines) or not lines[idx].startswith('\"'):\n   print(\"Error: missing input string line\",file=sys.stderr)\n   sys.exit(1)\n  input_line=lines[idx]\n  input_str=input_line[1:-1] if input_line.endswith('\"') and input_line.startswith('\"') else ''\n  idx+=1\n  current=initial_state\n  for ch in input_str:\n   current=transitions.get(current,{}).get(ch)\n   if current is None:break\n  result=\"Accept\" if current in accept_states else \"Reject\"\n  print(f\"{current if current is not None else 'None'} {result}\")\nif __name__=='__main__':main()"
  },
  {
    "id": "diamonds",
    "description": "Draw a size ascending range of diamonds using the numbers 1 to\n9, ranging from size 1 to size 9, each diamond\nseparated by a blank line.A size 1 diamond should look like\nthis, a single centered 1:\n1\nWith the largest size 9 diamond looking like this:\n1\n121\n12321\n1234321\n123454321\n12345654321\n1234567654321\n123456787654321\n12345678987654321\n123456787654321\n1234567654321\n12345654321\n123454321\n1234321\n12321\n121\n1\nCopy Answer\nCopied",
    "solution": "MAX=9\nfor n in range(1,MAX+1):\n for i in range(1,n+1):\n  left=''.join(str(j)for j in range(1,i))\n  right=left[::-1]\n  s=f\"{left}{i}{right}\"\n  print(' '*(10-i)+s)\n for i in range(n-1,0,-1):\n  left=''.join(str(j)for j in range(1,i))\n  right=left[::-1]\n  s=f\"{left}{i}{right}\"\n  print(' '*(10-i)+s)\n if n!=MAX:print()"
  },
  {
    "id": "divisors",
    "description": "A number is a divisor of another number if it can divide into it with no\nremainder.\nPrint the positive divisors of each number from 1 to 100\ninclusive, on their own line, with each divisor separated by a space.\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def find_divisors_and_print(n):\n  \"\"\"\n  Finds the positive divisors of a number and prints them on a single line.\n\n  Args:\n    n: The number to find divisors for.\n  \"\"\"\n  divisors = []\n  for i in range(1, n + 1):\n    if n % i == 0:\n      divisors.append(str(i))  # Convert to string for easy joining\n\n  print(\" \".join(divisors))\n\n\n# Iterate from 1 to 100 and find divisors for each number\nfor num in range(1, 101):\n  find_divisors_and_print(num)"
  },
  {
    "id": "emirp-numbers",
    "description": "An emirp (prime spelled backwards) is a prime number that results in a\ndifferent prime when its decimal digits are reversed. For example\nboth 13 and 31 are emirps, but 131 is not.\nPrint all the emirp numbers from 1 to\n1,000\ninclusive, each on their own line.\nVariants:\nEmirp Numbers (Long)\nOEIS A006567,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def sieve(n):\n is_prime=[False,False]+[True]*(n-1)\n for i in range(2,int(n**0.5)+1):\n  if is_prime[i]:\n   for j in range(i*i,n+1,i):is_prime[j]=False\n return is_prime\ndef reverse_int(x):\n return int(str(x)[::-1])\ndef main():\n limit=1000\n is_prime=sieve(limit)\n primes={i for i,v in enumerate(is_prime) if v}\n for p in sorted(primes):\n  q=reverse_int(p)\n  if q!=p and q in primes:print(p)\nif __name__=='__main__':main()"
  },
  {
    "id": "emirp-numbers-long",
    "description": "An emirp (prime spelled backwards) is a prime number that results in a\ndifferent prime when its decimal digits are reversed. For example\nboth 13 and 31 are emirps, but 131 is not.\nPrint all the emirp numbers from 1 to\n10,000\ninclusive, each on their own line.\nVariants:\nEmirp Numbers\nOEIS A006567,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_evil(n):\n return bin(n).count('1')%2==0\ndef main():\n for n in range(0,1001):\n  if is_evil(n):print(n)\nif __name__=='__main__':main()"
  },
  {
    "id": "emojify",
    "description": "Given each of the following ASCII emoticons print the corresponding\nUnicode emoji.\n:-D😀\n:-)🙂\n:-|😐\n:-(🙁\n:-\\😕\n:-*😗\n:-O😮\n:-#🤐\n':-D😅\n':-(😓\n:'-)😂\n:'-(😢\n:-P😛\n;-P😜\nX-P😝\nX-)😆\nO:-)😇\n;-)😉\n:-$😳\n:-😶\nB-)😎\n:-J😏\n}:-)😈\n}:-(👿\n:-@😡\nWikipedia\nCopy as JSON\nCopied",
    "solution": "import sys\nm={\":-D\":\"😀\",\":-)\":\"🙂\",\":-|\":\"😐\",\":-(\":\"🙁\",\":-\\\\\":\"😕\",\":-*\":\"😗\",\":-O\":\"😮\",\":-#\":\"🤐\",\"':-D\":\"😅\",\"':-(\":\"😓\",\":'-)\":\"😂\",\":'-(\":\"😢\",\":-P\":\"😛\",\";-P\":\"😜\",\"X-P\":\"😝\",\"X-)\":\"😆\",\"O:-)\":\"😇\",\";-)\":\"😉\",\":-$\":\"😳\",\":-\":\"😶\",\"B-)\":\"😎\",\":-J\":\"😏\",\"}:-)\":\"😈\",\"}:-(\":\"👿\",\":-@\":\"😡\"}\nfor arg in sys.argv[1:]:\n print(m.get(arg,arg))"
  },
  {
    "id": "evil-numbers",
    "description": "An evil number is a non-negative number that has an even number of 1s in\nits binary expansion.\nPrint all the evil numbers from 0 to\n50\ninclusive, each on their own line.\nVariants:\nEvil Numbers (Long),\nOdious Numbers,\nOdious Numbers (Long)\nOEIS A001969,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_evil(n):\n    \"\"\"\n    Checks if a number is an evil number.\n\n    An evil number is a non-negative number that has an even number of 1s in\n    its binary expansion.\n    \"\"\"\n    binary_representation = bin(n)[2:]  # Convert to binary and remove \"0b\" prefix\n    count_of_ones = binary_representation.count('1')\n    return count_of_ones % 2 == 0\n\ndef find_evil_numbers(limit):\n    \"\"\"\n    Prints all evil numbers from 0 to limit inclusive.\n    \"\"\"\n    for i in range(limit + 1):\n        if is_evil(i):\n            print(i)\n\nif __name__ == \"__main__\":\n    find_evil_numbers(50)"
  },
  {
    "id": "evil-numbers-long",
    "description": "An evil number is a non-negative number that has an even number of 1s in\nits binary expansion.\nPrint all the evil numbers from 0 to\n1,000\ninclusive, each on their own line.\nVariants:\nEvil Numbers,\nOdious Numbers,\nOdious Numbers (Long)\nOEIS A001969,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_evil(n):\n return bin(n).count('1')%2==0\ndef main():\n for n in range(0,1001):\n  if is_evil(n):print(n)\nif __name__=='__main__':main()"
  },
  {
    "id": "factorial-factorisation",
    "description": "Print the factorisation of 1000!,\n2^994*3^498*5^249*7^164*11^98*13^81*17^61*19^54*23^44*...*983*991*997\n.\nWikipedia\nCopy Answer\nCopied",
    "solution": "import math\ndef get_primes(n):\n sieve=[True]*(n+1)\n sieve[0:2]=[False,False]\n for i in range(2,int(n**0.5)+1):\n  if sieve[i]:\n   for j in range(i*i,n+1,i):sieve[j]=False\n return [i for i,is_prime in enumerate(sieve) if is_prime]\ndef prime_exponents_in_factorial(n):\n primes=get_primes(n)\n factors=[]\n for p in primes:\n  exp=0\n  k=p\n  while k<=n:\n   exp+=n//k\n   k*=p\n  factors.append((p,exp))\n return factors\ndef print_factorization(factors):\n parts=[]\n for p,e in factors:\n  if e==1:parts.append(f\"{p}\")\n  else:parts.append(f\"{p}^{e}\")\n print(\"*\".join(parts))\nfactors=prime_exponents_in_factorial(1000)\nprint_factorization(factors)"
  },
  {
    "id": "farey-sequence",
    "description": "The Farey sequence of order n is the sequence of all reduced\nfractions within the range [0, 1], where each denominator is at most\nn.\nPrint the Farey sequence of order 50 in ascending order. The sequence\nbegins 0/1, 1/50, 1/49, ...\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def farey(n):\n    \"\"\"\n    Generates the Farey sequence of order n.\n\n    Args:\n        n: The order of the Farey sequence.\n\n    Returns:\n        A list of tuples, where each tuple represents a fraction (numerator, denominator).\n    \"\"\"\n    result = [(0, 1)]\n    a, b, c, d = 0, 1, 1, n\n    while c <= n:\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        result.append((a, b))\n    return result\n\nif __name__ == '__main__':\n    farey_sequence = farey(50)\n    for num, den in farey_sequence:\n        print(f\"{num}/{den}\")"
  },
  {
    "id": "fibonacci",
    "description": "The Fibonacci numbers are a numerical sequence in which each number is the\nsum of the two preceding numbers: 0, 1, 1, 2, 3, 5, 8, 13…\nPrint the first 31 Fibonacci numbers from F0 = 0\nto F30 = 832040 (inclusive), each on a separate line.\nOEIS A000045,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def fibonacci(n):\n  \"\"\"\n  生成斐波那契数列的前 n 个数字。\n\n  Args:\n    n: 要生成的斐波那契数字的数量。\n\n  Returns:\n    一个包含斐波那契数列前 n 个数字的列表。\n  \"\"\"\n  fib_list = []\n  a = 0\n  b = 1\n  for _ in range(n):\n    fib_list.append(a)\n    a, b = b, a + b\n  return fib_list\n\nif __name__ == \"__main__\":\n  fib_numbers = fibonacci(31)\n  for num in fib_numbers:\n    print(num)"
  },
  {
    "id": "fizz-buzz",
    "description": "Print the numbers from 1 to\n100\ninclusive, each on their own line.\nIf, however, the number is a multiple of three then print\nFizz instead, and if the number is a multiple of five then\nprint Buzz.\nIf multiple conditions hold true then all replacements should be printed,\nfor example 15 should print FizzBuzz.\nVariants:\nFoo Fizz Buzz Bar\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def fizzbuzz():\n  \"\"\"Prints numbers from 1 to 100, replacing multiples of 3 with \"Fizz\",\n  multiples of 5 with \"Buzz\", and multiples of both with \"FizzBuzz\".\n  \"\"\"\n  for i in range(1, 101):\n    output = \"\"\n    if i % 3 == 0:\n      output += \"Fizz\"\n    if i % 5 == 0:\n      output += \"Buzz\"\n\n    if output == \"\":\n      print(i)\n    else:\n      print(output)\n\nif __name__ == \"__main__\":\n  fizzbuzz()"
  },
  {
    "id": "foo-fizz-buzz-bar",
    "description": "Print the numbers from 1 to\n1,000\ninclusive, each on their own line.\nIf, however, the number is a multiple of two then print Foo\ninstead, if the number is a multiple of three then print\nFizz, if the number is a multiple of five then print\nBuzz, and if the number is a multiple of seven then print\nBar.\nIf multiple conditions hold true then all replacements should be printed,\nfor example 15 should print FizzBuzz.\nVariants:\nFizz Buzz\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def fizzbuzz():\n  \"\"\"\n  Prints numbers from 1 to 1000, replacing multiples of 2, 3, 5, and 7 with\n  \"Foo\", \"Fizz\", \"Buzz\", and \"Bar\" respectively. If a number is a multiple\n  of multiple of these numbers, it prints all the corresponding replacements.\n  \"\"\"\n  for i in range(1, 1001):\n    output = \"\"\n    if i % 2 == 0:\n      output += \"Foo\"\n    if i % 3 == 0:\n      output += \"Fizz\"\n    if i % 5 == 0:\n      output += \"Buzz\"\n    if i % 7 == 0:\n      output += \"Bar\"\n\n    if output == \"\":\n      print(i)\n    else:\n      print(output)\n\nif __name__ == \"__main__\":\n  fizzbuzz()"
  },
  {
    "id": "forsyth-edwards-notation",
    "description": "Forsyth–Edwards Notation (FEN) is a standard notation for describing a\nparticular board position of a chess game.\nThe standard starting chess position is encoded as\nrnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\nThe first of the space separated groups is the main part which encodes the\nphysical positions of the pieces on the board.\nEach rank (row) is described, starting with rank 8 and ending with rank 1;\nwithin each rank, the contents of each square are described from file\n(column) \"a\" through file \"h\". Each piece is identified by a single letter\ntaken from the standard English names (Pawn, kNight,\nBishop, Rook, Queen, King). White pieces are\ndesignated using upper-case letters (\"PNBRQK\") while black pieces use\nlowercase (\"pnbrqk\"). Empty squares are noted using digits 1 through 8\n(the number of empty squares), and \"/\" separates ranks.\nGiven a FEN, output the board using the chess unicode characters and a\nspace for empty squares. The output corresponding to the FEN of the\nstarting position given above should be\n♜♞♝♛♚♝♞♜\n♟♟♟♟♟♟♟♟\n♙♙♙♙♙♙♙♙\n♖♘♗♕♔♗♘♖\nWikipedia",
    "solution": "import sys\npieces={'K':'♔','Q':'♕','R':'♖','B':'♗','N':'♘','P':'♙','k':'♚','q':'♛','r':'♜','b':'♝','n':'♞','p':'♟'}\nfor arg in sys.argv[1:]:\n fen=arg.split()[0]\n for row in fen.split('/'):\n  line=''\n  for c in row:\n   if c.isdigit():line+=' '*int(c)\n   else:line+=pieces[c]\n  print(line)\n print()"
  },
  {
    "id": "fractions",
    "description": "For each fraction argument a/b, reduce it to its simplest form.\nWikipedia",
    "solution": "import sys,math\nfor arg in sys.argv[1:]:\n a,b=map(int,arg.split('/'))\n g=math.gcd(a,b)\n print(f'{a//g}/{b//g}')"
  },
  {
    "id": "game-of-life",
    "description": "The universe of the Game of Life is a grid of square cells, each of which\nis either alive (\"#\") or dead (\".\"). Every cell interacts with its eight\nneighbours, which are the cells that are horizontally, vertically, or\ndiagonally adjacent. At each step in time, the following transitions occur:\nAny dead cell with exactly three live neighbours becomes a live cell.\nAll other dead cells stay dead.\nAny live cell with two or three live neighbours survives.\nAll other live cells die.\nGiven a 32×32 grid, output the state in the next step. Assume that every\ncell outside the grid is dead.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef next_gen(grid):\n out=[]\n for i in range(32):\n  row=''\n  for j in range(32):\n   cnt=0\n   for di in (-1,0,1):\n    for dj in (-1,0,1):\n     if di==0 and dj==0:continue\n     ni,nj=i+di,j+dj\n     if 0<=ni<32 and 0<=nj<32 and grid[ni][nj]=='#':cnt+=1\n   row+='#' if (grid[i][j]=='#' and cnt in (2,3))or(grid[i][j]=='.' and cnt==3)else '.'\n  out.append(row)\n return out\nfor arg in sys.argv[1:]:\n lines=arg.splitlines()\n if len(lines)==1 and len(lines[0])==1024:grid=[list(lines[0][i*32:(i+1)*32])for i in range(32)]\n else:grid=[list(lines[i])for i in range(32)]\n for ln in next_gen(grid):print(ln)"
  },
  {
    "id": "gijswijts-sequence",
    "description": "Gijswijt’s sequence is a slow-growing sequence where each term counts the\nmaximum number of repeated blocks of numbers in the sequence immediately\npreceding that term.\nThe sequence begins 1, 1, 2, 1, 1, 2, 2, 2, 3, 1 ... and its construction\ncan be seen in the following figure.\n[1]\n[1],[1]\n1 , 1 ,[2]\n1 , 1 , 2 ,[1]\n1 , 1 , 2 ,[1],[1]\n[1 , 1 , 2],[1 , 1 , 2]\n1 , 1 , 2 , 1 , 1 ,[2],[2]\n1 , 1 , 2 , 1 , 1 ,[2],[2],[2]\n1 , 1 , 2 , 1 , 1 , 2 , 2 , 2 ,[3]\n1 , 1 , 2 , 1 , 1 , 2 , 2 , 2 , 3 , 1\nOn each line, the blocks that are used to get the next number in the\nsequence are marked in []. Print the first 1,000 terms of\nGijswijt’s sequence, each on a separate line.\nOEIS A090822,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def gijswijt(n_terms):\n seq=[1]\n for m in range(1,n_terms):\n  max_k=1\n  for L in range(1,m+1):\n   block=seq[-L:]\n   k=0\n   while L*(k+1)<=m and seq[-L*(k+1):]==block*(k+1):k+=1\n   if k>max_k:max_k=k\n  seq.append(max_k)\n return seq\nif __name__=='__main__':\n for x in gijswijt(1000):print(x)"
  },
  {
    "id": "happy-numbers",
    "description": "A happy number is defined by the following Sequence: Starting with any\npositive integer, replace the number by the sum of the squares of its\ndigits in base-ten, and repeat the process until the number either equals\n1 (where it will stay), or it loops endlessly in a cycle that does not\ninclude 1. Those numbers for which this process ends in 1 are happy\nnumbers, while those that do not end in 1 are sad numbers.\nFor example, 19 is happy, as the associated Sequence is:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1.\nPrint all the happy numbers from 1 to\n200\ninclusive, each on their own line.\nVariants:\nHappy Numbers (Long)\nOEIS A007770,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_happy(n):\n    \"\"\"\n    判断一个数字是否是快乐数。\n\n    Args:\n        n: 要检查的数字。\n\n    Returns:\n        如果数字是快乐数，则返回 True，否则返回 False。\n    \"\"\"\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        sum_of_squares = 0\n        while n > 0:\n            digit = n % 10\n            sum_of_squares += digit ** 2\n            n //= 10\n        n = sum_of_squares\n    return n == 1\n\n\ndef find_happy_numbers(limit):\n    \"\"\"\n    查找并打印从 1 到 limit（包括 limit）的所有快乐数。\n\n    Args:\n        limit: 要搜索到的上限。\n    \"\"\"\n    for i in range(1, limit + 1):\n        if is_happy(i):\n            print(i)\n\n\nif __name__ == \"__main__\":\n    find_happy_numbers(200)"
  },
  {
    "id": "happy-numbers-long",
    "description": "A happy number is defined by the following Sequence: Starting with any\npositive integer, replace the number by the sum of the squares of its\ndigits in base-ten, and repeat the process until the number either equals\n1 (where it will stay), or it loops endlessly in a cycle that does not\ninclude 1. Those numbers for which this process ends in 1 are happy\nnumbers, while those that do not end in 1 are sad numbers.\nFor example, 19 is happy, as the associated Sequence is:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1.\nPrint all the happy numbers from 1 to\n1,000\ninclusive, each on their own line.\nVariants:\nHappy Numbers\nOEIS A007770,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def sum_of_squares(n):\n  \"\"\"计算一个数的各位数字的平方和。\"\"\"\n  sum_sq = 0\n  while n > 0:\n    digit = n % 10\n    sum_sq += digit * digit\n    n //= 10\n  return sum_sq\n\ndef is_happy(n):\n  \"\"\"判断一个数是否是快乐数。\"\"\"\n  seen = set()\n  while n != 1 and n not in seen:\n    seen.add(n)\n    n = sum_of_squares(n)\n  return n == 1\n\n# 打印 1 到 1000 之间的所有快乐数。\nfor i in range(1, 1001):\n  if is_happy(i):\n    print(i)"
  },
  {
    "id": "hexdump",
    "description": "Given a string, output the hexdump of the string as given by the xxd\nutility using the default settings, as described below.\nDivide up the input string into groups of 16 bytes (16 octets). For each\ngroup, print in order:\nThe (hexadecimal, lowercase) index of the starting octet, padded with\nzeros to eight hexadecimal digits\nA single colon (:), followed by a single space.\n8 space-separated pairs of octets, with each pair printed as 4\nhexadecimal digits\nSpaces to pad to 51 bytes\nThe original 16 bytes, except with newline replaced with full stop\n(.)",
    "solution": "import sys\ndef hexdump(data):\n for offset in range(0,len(data),16):\n  chunk=data[offset:offset+16]\n  prefix=f\"{offset:08x}: \"\n  groups=[]\n  for i in range(8):\n   pair=chunk[2*i:2*i+2]\n   if len(pair)==2:groups.append(f\"{pair[0]:02x}{pair[1]:02x}\")\n   elif len(pair)==1:groups.append(f\"{pair[0]:02x}  \")\n   else:groups.append(\"    \")\n  hex_part=\" \".join(groups)\n  pad=51-(len(prefix)+len(hex_part))\n  ascii_part=\"\".join((chr(b)if 32<=b<127 and b!=10 else\".\")for b in chunk)\n  print(prefix+hex_part+\" \"*pad+ascii_part)\nif __name__=='__main__':\n for arg in sys.argv[1:]:\n  data=arg.encode(\"utf-8\")\n  hexdump(data)\n  print()"
  },
  {
    "id": "intersection",
    "description": "A box is defined via x, y, w and h as\ny\n│ ┌───w───┐\n│ │   ┌───┼──┐\n│ h   │▓▓▓│  │\n│ │   │▓▓▓│  │\n│ o───┼───┘  │\n│     o──────┘\n└───────────────x\n(0,0)\nCompute the intersection area between two boxes given as\nx1 y1 w1 h1 x2 y2 w2 h2\nWikipedia",
    "solution": "import sys\ntokens=[]\nfor arg in sys.argv[1:]:tokens.extend(arg.split())\nnums=list(map(int,tokens))\nfor i in range(0,len(nums),8):\n x1,y1,w1,h1,x2,y2,w2,h2=nums[i:i+8]\n overlap_w=max(0,min(x1+w1,x2+w2)-max(x1,x2))\n overlap_h=max(0,min(y1+h1,y2+h2)-max(y1,y2))\n print(overlap_w*overlap_h)"
  },
  {
    "id": "inventory-sequence",
    "description": "We will build a sequence by repeatedly taking inventory.\nWe take inventory each time we add 0 to the sequence.\nTo take inventory we start by counting the number of zeros in the sequence\nand add the number to the end of the sequence, then we continue by\ncounting the number of ones and add that to the sequence and so on.\nWe stop when we reach a number that is not in the sequence and we add 0 to\nthe sequence then start over.\nThe first few terms are as follows:\n0 1 2 3 4 5\n-----------\n0\n1 1 0\n2 2 2 0\n3 2 4 1 1 0\n4 4 4 1 4 0\nPrint the first 1,000 terms of the inventory sequence,\neach on their own line.\nNumberphile,\nOEIS A342585,\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def inventory_sequence(n):\n seq=[0]\n while len(seq)<n:\n  k=0\n  while True:\n   c=seq.count(k)\n   seq.append(c)\n   if c==0 or len(seq)>=n:break\n   k+=1\n return seq[:n]\nif __name__=='__main__':\n for x in inventory_sequence(1000):print(x)"
  },
  {
    "id": "isbn",
    "description": "Calculate the check digit for these incomplete ISBNs.\nIf the check digit would be 10, write \"X\" instead.\nThe check digit of a-bcdef-ghi-? is computed as\n− 10a − 9b − 8c − … − 2i, modulo 11.\nDashes may occur in varying positions and are ignored.\nWikipedia",
    "solution": "import sys\ndef calc_check(s):\n ds=[int(c)for c in s if c.isdigit()][:9]\n total=sum((10-i)*d for i,d in enumerate(ds))\n x=(-total)%11\n return 'X' if x==10 else str(x)\nfor arg in sys.argv[1:]:\n chk=calc_check(arg)\n print(arg+chk)"
  },
  {
    "id": "jacobi-symbol",
    "description": "For each argument a n, print the value of the Jacobi symbol\nJ(a, n).\nBoth inputs are non-negative integers, and n is odd.\nJ(a, 1) is defined as 1.\nIf n is prime, then J(a, n) is defined as 0 if\na=0 (mod n), as 1 if a is a square modulo n,\nand −1 otherwise.\nIf n = x*y, x,y>1, then J(a, n) is defined as\nJ(a, x)*J(a, y).\nNote that calculating the symbol from the definition is not very efficient\nas it requires factorisation of n.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef jacobi(a,n):\n if n<=0 or n%2==0:return 0\n a%=n\n r=1\n while a:\n  while a%2==0:\n   a//=2\n   if n%8 in(3,5):r=-r\n  a,n=n,a\n  if a%4==n%4==3:r=-r\n  a%=n\n return r if n==1 else 0\nfor arg in sys.argv[1:]:\n a,n=map(int,arg.split())\n print(jacobi(a,n))"
  },
  {
    "id": "kaprekar-numbers(Time limit exceeded)",
    "description": "Any positive integer is a Kaprekar number on the following conditions:\nthe integer is 1 or when splitting the integer's square in two\nmakes their sum equal the original integer.\nFor example, the square of 55 equals 3,025. Splitting the\nsquare in 30 and 25 makes their sum equal 55. Both\noperands must not equal zero, and must retain their digit order,\nbut they may differ in length.\nPrint all the Kaprekar numbers from 1 to 25,000,000\ninclusive, each on their own line.\nOEIS A006886,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def kaprekar_numbers(limit):\n    \"\"\"\n    Prints all Kaprekar numbers from 1 to limit inclusive.\n\n    Args:\n        limit: The upper limit for finding Kaprekar numbers.\n    \"\"\"\n\n    for num in range(1, limit + 1):\n        if num == 1:\n            print(num)\n            continue\n\n        square = num * num\n        square_str = str(square)\n        length = len(square_str)\n\n        for i in range(1, length):\n            right = int(square_str[i:])\n            left = int(square_str[:i])\n\n            if left == 0 or right == 0:\n                continue\n\n            if left + right == num:\n                print(num)\n                break  # Move to the next number\n\nif __name__ == \"__main__\":\n    kaprekar_numbers(25000000)"
  },
  {
    "id": "kolakoski-constant",
    "description": "The Kolakoski constant is created by taking the\nKolakoski sequence, subtracting one from\neach element, and then interpreting it as a binary fraction.\n1 221121221221121122121121…\n0.110010110110010011010010…\n0.7945071927…\nPrint the first 1,000 decimal digits of the Kolakoski constant.\nVariants:\nKolakoski Sequence\nOEIS A118270,\nWikipedia\nCopy Answer\nCopied",
    "solution": "from decimal import Decimal,getcontext\ngetcontext().prec=1005\ndef g(n):\n s=[1,2,2]\n i=2\n while len(s)<n:\n  s+=[1 if s[-1]==2 else 2]*s[i]\n  i+=1\n return s[:n]\nk=g(5000)\nb=int(''.join(str(x-1)for x in k[1:]),2)\nd=Decimal(b)/2**(len(k)-1)\nprint(str(d)[:1002])"
  },
  {
    "id": "kolakoski-sequence",
    "description": "The Kolakoski sequence is a self referential sequence where the nth\nelement is the length of the nth run of same numbers in the sequence.\nThis has the interesting property where if you take the run lengths of\nthis sequence, then you will get the same sequence back again. For\nexample, the sequence starting with (1, 2) looks like:\n1 2 2 1 1 2 1 2 2 1 2 2 1 1 2 1 1 2 2 1 2 1 1 2 1…\n1  2   2  1 1  2  1  2   2  1  2   2  1 1  2  1 1…\nBeginning with (1, 2) print the first 1,000 elements in the\nKolakoski sequence, separated by spaces.\nVariants:\nKolakoski Constant\nOEIS A000002,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def generate_kolakoski_sequence(length):\n sequence=[1,2,2]\n index=2\n while len(sequence)<length:\n  next_value=3-sequence[-1]\n  repeat=sequence[index]\n  sequence.extend([next_value]*repeat)\n  index+=1\n return sequence[:length]\ndef main():\n length=1000\n kolakoski_seq=generate_kolakoski_sequence(length)\n print(' '.join(map(str,kolakoski_seq)))\nif __name__=='__main__':main()"
  },
  {
    "id": "leap-years",
    "description": "In the Gregorian calendar, a leap year is created by extending February\nto 29 days in order to keep the calendar year synchronized with the\nastronomical year. These longer years occur in years which are multiples\nof 4, with the exception of centennial years that aren’t multiples\nof 400.\nWrite a program to print all the leap years from the year 1800 up\nto and including 2400.\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def is_leap_year(year):\n    \"\"\"\n    Checks if a given year is a leap year according to the Gregorian calendar rules.\n    \"\"\"\n    if year % 4 == 0:\n        if year % 100 == 0:\n            if year % 400 == 0:\n                return True\n            else:\n                return False\n        else:\n            return True\n    else:\n        return False\n\ndef print_leap_years(start_year, end_year):\n    \"\"\"\n    Prints all leap years between start_year and end_year (inclusive).\n    \"\"\"\n    for year in range(start_year, end_year + 1):\n        if is_leap_year(year):\n            print(year)\n\nif __name__ == \"__main__\":\n    print_leap_years(1800, 2400)"
  },
  {
    "id": "levenshtein-distance",
    "description": "The Levenshtein distance is the minimum number of single character edits\nthat are needed to transform one word into another. The available edits\nare deletion, insertion, or substitution of a single character.\nFor example the Levenshtein distance between “shine” and\n“train” is 4:\nshine → shin (deletion of 'e')\nshin → tshin (insertion of 't')\ntshin → trhin (substitution of 's' for 'r')\ntrhin → train (substitution of 'h' for 'a')\nFor each pair of words per argument, print the Levenshtein distance on its\nown line.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef levenshtein_distance(s1,s2):\n m,n=len(s1),len(s2)\n dp=[[0]*(n+1)for _ in range(m+1)]\n for i in range(m+1):dp[i][0]=i\n for j in range(n+1):dp[0][j]=j\n for i in range(1,m+1):\n  for j in range(1,n+1):\n   cost=0 if s1[i-1]==s2[j-1]else 1\n   dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost)\n return dp[m][n]\ndef main():\n args=sys.argv[1:]\n for arg in args:\n  words=arg.split()\n  if len(words)!=2:continue\n  word1,word2=words[0],words[1]\n  distance=levenshtein_distance(word1,word2)\n  print(distance)\nif __name__=='__main__':main()"
  },
  {
    "id": "leyland-numbers",
    "description": "A Leyland number is of the form xy + yx where\n1 < y ≤ x.\nFor example, 8 is a Leyland number because\n22 + 22 = 8.\nPrint all the Leyland numbers from 1 to 100,000,000,000\ninclusive, each on their own line.\nOEIS A076980,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def solve_leyland_numbers():\n leyland_numbers=set()\n max_limit=100_000_000_000\n for y in range(2,12):\n  for x in range(y,320000):\n   number=x**y+y**x\n   if number>max_limit:break\n   leyland_numbers.add(number)\n sorted_numbers=sorted(list(leyland_numbers))\n for number in sorted_numbers:print(number)\nif __name__=='__main__':solve_leyland_numbers()"
  },
  {
    "id": "ln-2",
    "description": "Print the first 1,000 decimal digits of ln 2 (the natural logarithm of 2).\nOEIS A002162,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal,getcontext\ngetcontext().prec=1010\nln2=Decimal(2).ln()\nln2_str=format(ln2,'.1010f')\nprint(ln2_str[0:1002])"
  },
  {
    "id": "look-and-say",
    "description": "The Look and Say sequence starts with 1 and is continued by looking at\neach of the runs of the same number in the previous term and combining the\nlength with the original number. For example the next term after 111221\nwould be 312211 (three ones, two twos and one one).\nPrint the first 20 terms of the Look and Say sequence.\nOEIS A005150,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def look_and_say(s):\n    \"\"\"\n    Generates the next term in the Look and Say sequence.\n\n    Args:\n        s: The previous term in the sequence (as a string).\n\n    Returns:\n        The next term in the sequence (as a string).\n    \"\"\"\n    result = \"\"\n    count = 1\n    for i in range(len(s)):\n        if i + 1 < len(s) and s[i] == s[i + 1]:\n            count += 1\n        else:\n            result += str(count) + s[i]\n            count = 1\n    return result\n\n# Generate and print the first 20 terms of the Look and Say sequence\nstart = \"1\"\nfor i in range(20):\n    print(start)\n    start = look_and_say(start)"
  },
  {
    "id": "lucky-numbers",
    "description": "The lucky numbers are an integer sequence that results from a\ncertain \"sieve\" process:\nStart from the odd natural numbers a = 1 3 5 7 … viewed as a\n1-indexed infinite sequence.\nFor each k = 2…∞, replace a with the result of deleting\nevery a[k]-th term from a.\nPrint the first 1,000 terms of the resulting sequence.\nStart:\n1 3 5 7 9 11 13 15 …\n^\nDelete every 3rd term and advance:\n1 3 7 9 13 15 19 21 …\n^\nDelete every 7th term and advance:\n1 3 7 9 13 15 21 25 …\n^\nOEIS A000959,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def find_lucky_numbers(n):\n lucky_numbers_sequence=list(range(1,40000,2))\n k=2\n while k<len(lucky_numbers_sequence):\n  p=lucky_numbers_sequence[k-1]\n  lucky_numbers_sequence=[num for index,num in enumerate(lucky_numbers_sequence)if(index+1)%p!=0]\n  k+=1\n return lucky_numbers_sequence[:n]\nfirst_1000_lucky_numbers=find_lucky_numbers(1000)\nfor number in first_1000_lucky_numbers:print(number)"
  },
  {
    "id": "lucky-tickets",
    "description": "In Russia, bus ticket numbers consist of 6 decimal digits. It is\nconsidered lucky when the sum of the first three digits equals the sum of\nthe last three digits. The concept of lucky tickets can be extended to\nticket numbering systems with even numbers of digits and arbitrary bases.\nEach argument describes a ticket numbering system and consists of two\nnumbers separated by a space. The first is the even number of digits\n2 ≤ d ≤ 14. The second is the base of the numbering system\n2 ≤ b ≤ 16. For each argument, output the total number of lucky\ntickets for the numbering system on a separate line.\nOEIS A174061",
    "solution": "import sys\ndef count_lucky_tickets(d,b):\n half_digits=d//2\n max_sum=half_digits*(b-1)\n dp=[[0]*(max_sum+1)for _ in range(half_digits+1)]\n dp[0][0]=1\n for i in range(1,half_digits+1):\n  for j in range(max_sum+1):\n   for k in range(b):\n    if j-k>=0:dp[i][j]+=dp[i-1][j-k]\n half_ticket_ways=dp[half_digits]\n total_lucky_tickets=sum(ways**2 for ways in half_ticket_ways)\n return total_lucky_tickets\ndef main():\n if len(sys.argv)<2:return\n for arg in sys.argv[1:]:\n  try:\n   d_str,b_str=arg.split()\n   d=int(d_str)\n   b=int(b_str)\n   if not(2<=d<=14 and d%2==0):print(f\"错误: 票号位数 d={d} 必须是2到14之间的偶数。\");continue\n   if not(2<=b<=16):print(f\"错误: 进制 b={b} 必须是2到16之间。\");continue\n   result=count_lucky_tickets(d,b)\n   print(result)\n  except ValueError:print(f\"错误: 参数 '{arg}' 格式不正确，应为 'd b'。\")\nif __name__=='__main__':main()"
  },
  {
    "id": "mahjong",
    "description": "Given a list of mahjong hands, print out all of the hands which are\ncomplete under the rules of Riichi Mahjong.\nMahjong tiles are divided into three suits of number tiles\nfrom 1 to 9, and seven honor tiles, which are not numbered.\nThese are the Unicode characters representing the tiles in each suit,\nfrom 1 to 9:\nCharacters 🀇🀈🀉🀊🀋🀌🀍🀎🀏\nBamboo 🀐🀑🀒🀓🀔🀕🀖🀗🀘\nCircles 🀙🀚🀛🀜🀝🀞🀟🀠🀡\nThese are the Unicode characters representing honor tiles: 🀀🀁🀂🀃🀄🀅🀆\nA triplet is a group of three identical tiles, e.g. 🀓🀓🀓 or 🀅🀅🀅.\nA sequence is a group of three number tiles of the same suit and\nwith consecutive numbers, e.g. 🀇🀈🀉 or 🀜🀝🀞.\nA meld is either a triplet or a sequence.\nA pair is a group of two identical tiles.\nA mahjong hand is complete if it consists of one of the following:\nFour melds and a pair.\nSeven distinct pairs. Four of the same tile do not count as two pairs.\nAll seven honor tiles and the 1 and 9 of each suit,\nplus one duplicate tile that forms a pair.\nThe tiles in a mahjong hand are not ordered. For example,\nthe hand 🀇🀈🀈🀈🀉🀓🀔🀕🀚🀛🀜🀀🀀🀀 is complete,\nas it can be split into the groups 🀇🀈🀉 🀓🀔🀕 🀚🀛🀜 🀀🀀🀀 🀈🀈.\nYou may assume that no hand contains more than 4 of a single tile.\nThe input consists of a sequence of arguments, each containing a string of\n14 Unicode characters which represent the tiles in the hand. Output the\narguments that represent complete mahjong hands, in the same order as they\nappear in the argument list.\nWikipedia",
    "solution": "import sys\nfrom collections import Counter\nCHARACTERS=\"🀇🀈🀉🀊🀋🀌🀍🀎🀏\"\nBAMBOO=\"🀐🀑🀒🀓🀔🀕🀖🀗🀘\"\nCIRCLES=\"🀙🀚🀛🀜🀝🀞🀟🀠🀡\"\nHONORS=\"🀀🀁🀂🀃🀄🀅🀆\"\nSUITS=[CHARACTERS,BAMBOO,CIRCLES]\nALL_TILES=HONORS+''.join(SUITS)\ndef get_first_tile(counts):\n for tile in ALL_TILES:\n  if counts[tile]>0:return tile\n return None\ndef is_number_tile(tile):\n return tile in CHARACTERS or tile in BAMBOO or tile in CIRCLES\ndef get_next_tile(tile,suit_str):\n try:\n  index=suit_str.index(tile)\n  if index<8:return suit_str[index+1]\n except ValueError:pass\n return None\ndef can_form_melds(counts):\n first_tile=get_first_tile(counts)\n if not first_tile:return True\n if counts[first_tile]>=3:\n  new_counts=counts.copy()\n  new_counts[first_tile]-=3\n  if can_form_melds(new_counts):return True\n if is_number_tile(first_tile):\n  for suit_str in SUITS:\n   if first_tile in suit_str:\n    next_tile=get_next_tile(first_tile,suit_str)\n    if next_tile and counts[next_tile]>=1:\n     next_next_tile=get_next_tile(next_tile,suit_str)\n     if next_next_tile and counts[next_next_tile]>=1:\n      new_counts=counts.copy()\n      new_counts[first_tile]-=1\n      new_counts[next_tile]-=1\n      new_counts[next_next_tile]-=1\n      if can_form_melds(new_counts):return True\n    break\n return False\ndef is_standard_complete(counts):\n if sum(counts.values())!=14:return False\n for tile in counts:\n  if counts[tile]>=2:\n   new_counts=counts.copy()\n   new_counts[tile]-=2\n   if can_form_melds(new_counts):return True\n return False\ndef is_seven_pairs(counts):\n return len(counts)==7 and all(c==2 for c in counts.values())\ndef is_thirteen_orphans(counts):\n thirteen_orphans_tiles=HONORS+CHARACTERS[0]+CHARACTERS[8]+BAMBOO[0]+BAMBOO[8]+CIRCLES[0]+CIRCLES[8]\n if len(counts)!=13:return False\n if any(tile not in thirteen_orphans_tiles for tile in counts):return False\n pair_count=0\n for c in counts.values():\n  if c==2:pair_count+=1\n  elif c!=1:return False\n return pair_count==1\ndef is_complete(hand_str):\n counts=Counter(hand_str)\n if sum(counts.values())!=14:return False\n if is_seven_pairs(counts):return True\n if is_thirteen_orphans(counts):return True\n if is_standard_complete(counts):return True\n return False\ndef main():\n if len(sys.argv)<2:return\n for hand_str in sys.argv[1:]:\n  if is_complete(hand_str):print(hand_str)\nif __name__=='__main__':main()"
  },
  {
    "id": "mandelbrot",
    "description": "The Mandelbrot set is the set of complex numbers c for which the\nsequence a(1) = 0, a(n+1) = a(n)² + c does not diverge to infinity.\nConsider the section of the complex plane where\n-2 ≤ Re c ≤ 0.5, -1 ≤ Im c ≤ 1 divided into a 41×81 lattice.\nDraw the Mandelbrot set using this grid. That is, for each such lattice\npoint, print █ (U+2588) if it belongs to the set and ▒ (U+2592) if it\ndoesn't. Note that for each of the lattice points, 1063 iterations are\nenough to determine whether the sequence corresponding to the point is\nunbounded or not.\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def draw_mandelbrot_set():\n width=81\n height=41\n max_iterations=1063\n min_real=-2.0\n max_real=0.5\n min_imag=-1.0\n max_imag=1.0\n for i in range(height):\n  for j in range(width):\n   c_real=min_real+j*(max_real-min_real)/(width-1)\n   c_imag=max_imag-i*(max_imag-min_imag)/(height-1)\n   c=complex(c_real,c_imag)\n   a=complex(0,0)\n   is_in_set=True\n   for _ in range(max_iterations):\n    a=a**2+c\n    if abs(a)>2:is_in_set=False;break\n   print('█'if is_in_set else'▒',end='')\n  print()\nif __name__=='__main__':draw_mandelbrot_set()"
  },
  {
    "id": "maze",
    "description": "For a given maze, find the shortest path from Start to End\npoints. Output the path in the maze with dots. For example:\n###########       ###########\n#S#      E#       #S#  ....E#\n# ### #####       #.###.#####\n#   #     #   →   #...#.....#\n### ##### #       ###.#####.#\n#         #       #  .......#\n###########       ###########\nRosetta Code,\nWikipedia",
    "solution": "import sys\nfrom collections import deque\ndef find_shortest_path(maze_string):\n maze_grid=[list(row)for row in maze_string.strip().split('\\n')]\n rows,cols=len(maze_grid),len(maze_grid[0])\n start_pos,end_pos=None,None\n for r in range(rows):\n  for c in range(cols):\n   if maze_grid[r][c]=='S':start_pos=(r,c)\n   elif maze_grid[r][c]=='E':end_pos=(r,c)\n if not start_pos or not end_pos:return \"错误: 迷宫中未找到起点或终点。\"\n queue=deque([start_pos])\n visited={start_pos}\n parent={start_pos:None}\n path_found=False\n while queue:\n  r,c=queue.popleft()\n  if(r,c)==end_pos:path_found=True;break\n  for dr,dc in[(-1,0),(1,0),(0,-1),(0,1)]:\n   nr,nc=r+dr,c+dc\n   if 0<=nr<rows and 0<=nc<cols and maze_grid[nr][nc]!='#'and(nr,nc)not in visited:\n    visited.add((nr,nc))\n    parent[(nr,nc)]=(r,c)\n    queue.append((nr,nc))\n if path_found:\n  path=[]\n  current=end_pos\n  while current:\n   path.append(current)\n   current=parent[current]\n  result_grid=[list(row)for row in maze_string.strip().split('\\n')]\n  for r,c in path:\n   if result_grid[r][c]not in('S','E'):result_grid[r][c]='.'\n  return '\\n'.join(''.join(row)for row in result_grid)\n else:return \"未找到路径。\"\ndef main():\n if len(sys.argv)<2:print(\"请提供一个或多个迷宫字符串作为命令行参数。\");return\n for i,maze_string in enumerate(sys.argv[1:]):\n  if i>0:print(\"-\"*20)\n  result=find_shortest_path(maze_string)\n  print(result)\nif __name__=='__main__':main()"
  },
  {
    "id": "medal-tally",
    "description": "Solutions on code.golf can be awarded one of three medals: bronze (🥉) for\n3rd place, silver (🥈) for 2nd place, or gold (🥇) for 1st place. In\naddition, an uncontested 1st place solution is awarded a diamond (💎).\nTied solutions are all awarded the same medal.\nGiven a list of space-separated solution scores in ascending order,\nprint the corresponding diamonds and medals.",
    "solution": "import sys\nfrom collections import Counter\ndef assign_medals_final(scores_str):\n try:scores=[int(s)for s in scores_str.split()]\n except ValueError:return f\"错误：输入 '{scores_str}' 包含无效字符。\"\n if not scores:return \"\"\n unique_scores=sorted(list(set(scores)))\n all_awarded_medals=[]\n current_rank=1\n for score_value in unique_scores:\n  if current_rank>3:break\n  score_count=scores.count(score_value)\n  if current_rank==1:\n   if score_count==1:\n    all_awarded_medals.append('💎')\n    all_awarded_medals.append('🥇')\n   else:all_awarded_medals.extend(['🥇']*score_count)\n  elif current_rank==2:all_awarded_medals.extend(['🥈']*score_count)\n  elif current_rank==3:all_awarded_medals.extend(['🥉']*score_count)\n  current_rank+=score_count\n if not all_awarded_medals:return \"\"\n medal_counts=Counter(all_awarded_medals)\n output_parts=[]\n medal_order=['💎','🥇','🥈','🥉']\n for medal in medal_order:\n  if medal_counts[medal]>0:output_parts.append(f\"{medal_counts[medal]}{medal}\")\n return ' '.join(output_parts)\ndef main():\n if len(sys.argv)<2:print(\"用法: python script.py \\\"<分数列表1>\\\" \\\"<分数列表2>\\\" ...\");return\n for scores_argument in sys.argv[1:]:\n  result=assign_medals_final(scores_argument)\n  print(result)\nif __name__=='__main__':main()"
  },
  {
    "id": "morse-decoder",
    "description": "Using ▄ (U+2584 Lower Half Block) to represent a dot,\ndecode the argument from International Morse Code to alphanumeric.\nThe length of a dot is one unit.\nA dash is three units.\nThe space between parts of the same letter is one unit.\nThe space between letters is three units.\nThe space between words is ten units.\nChr.\nCode\nA▄ ▄▄▄\nB▄▄▄ ▄ ▄ ▄\nC▄▄▄ ▄ ▄▄▄ ▄\nD▄▄▄ ▄ ▄\nE▄\nF▄ ▄ ▄▄▄ ▄\nG▄▄▄ ▄▄▄ ▄\nH▄ ▄ ▄ ▄\nI▄ ▄\nChr.\nCode\nJ▄ ▄▄▄ ▄▄▄ ▄▄▄\nK▄▄▄ ▄ ▄▄▄\nL▄ ▄▄▄ ▄ ▄\nM▄▄▄ ▄▄▄\nN▄▄▄ ▄\nO▄▄▄ ▄▄▄ ▄▄▄\nP▄ ▄▄▄ ▄▄▄ ▄\nQ▄▄▄ ▄▄▄ ▄ ▄▄▄\nR▄ ▄▄▄ ▄\nChr.\nCode\nS▄ ▄ ▄\nT▄▄▄\nU▄ ▄ ▄▄▄\nV▄ ▄ ▄ ▄▄▄\nW▄ ▄▄▄ ▄▄▄\nX▄▄▄ ▄ ▄ ▄▄▄\nY▄▄▄ ▄ ▄▄▄ ▄▄▄\nZ▄▄▄ ▄▄▄ ▄ ▄\n0▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄\nChr.\nCode\n1▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄\n2▄ ▄ ▄▄▄ ▄▄▄ ▄▄▄\n3▄ ▄ ▄ ▄▄▄ ▄▄▄\n4▄ ▄ ▄ ▄ ▄▄▄\n5▄ ▄ ▄ ▄ ▄\n6▄▄▄ ▄ ▄ ▄ ▄\n7▄▄▄ ▄▄▄ ▄ ▄ ▄\n8▄▄▄ ▄▄▄ ▄▄▄ ▄ ▄\n9▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄\nVariants:\nMorse Encoder\nRosetta Code,\nWikipedia\nCopy as JSON\nCopied",
    "solution": "import sys\ndef morse_decode(morse_code_str):\n MORSE_CODE_DICT={'.-':'A','-...':'B','-.-.':'C','-..':'D','.':'E','..-.':'F','--.':'G','....':'H','..':'I','.---':'J','-.-':'K','.-..':'L','--':'M','-.':'N','---':'O','.--.':'P','--.-':'Q','.-.':'R','...':'S','-':'T','..-':'U','...-':'V','.--':'W','-..-':'X','-.--':'Y','--..':'Z','-----':'0','.----':'1','..---':'2','...--':'3','....-':'4','.....':'5','-....':'6','--...':'7','---..':'8','----.':'9'}\n normalized_code=morse_code_str.replace('▄▄▄','-').replace('▄','.')\n words_morse=normalized_code.split('          ')\n decoded_words=[]\n for word_morse in words_morse:\n  letters_morse=word_morse.split('   ')\n  decoded_letters=[]\n  for letter_morse in letters_morse:\n   morse_unit=letter_morse.strip().replace(' ','');decoded_letters.append(MORSE_CODE_DICT.get(morse_unit,''))\n  decoded_words.append(''.join(decoded_letters))\n return ' '.join(decoded_words)\nif __name__=='__main__':\n if len(sys.argv)>1:\n  for arg in sys.argv[1:]:print(morse_decode(arg))"
  },
  {
    "id": "morse-encoder",
    "description": "Using ▄ (U+2584 Lower Half Block) to represent a dot,\nencode the argument from alphanumeric into International Morse Code.\nThe length of a dot is one unit.\nA dash is three units.\nThe space between parts of the same letter is one unit.\nThe space between letters is three units.\nThe space between words is ten units.\nChr.\nCode\nA▄ ▄▄▄\nB▄▄▄ ▄ ▄ ▄\nC▄▄▄ ▄ ▄▄▄ ▄\nD▄▄▄ ▄ ▄\nE▄\nF▄ ▄ ▄▄▄ ▄\nG▄▄▄ ▄▄▄ ▄\nH▄ ▄ ▄ ▄\nI▄ ▄\nChr.\nCode\nJ▄ ▄▄▄ ▄▄▄ ▄▄▄\nK▄▄▄ ▄ ▄▄▄\nL▄ ▄▄▄ ▄ ▄\nM▄▄▄ ▄▄▄\nN▄▄▄ ▄\nO▄▄▄ ▄▄▄ ▄▄▄\nP▄ ▄▄▄ ▄▄▄ ▄\nQ▄▄▄ ▄▄▄ ▄ ▄▄▄\nR▄ ▄▄▄ ▄\nChr.\nCode\nS▄ ▄ ▄\nT▄▄▄\nU▄ ▄ ▄▄▄\nV▄ ▄ ▄ ▄▄▄\nW▄ ▄▄▄ ▄▄▄\nX▄▄▄ ▄ ▄ ▄▄▄\nY▄▄▄ ▄ ▄▄▄ ▄▄▄\nZ▄▄▄ ▄▄▄ ▄ ▄\n0▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄\nChr.\nCode\n1▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄\n2▄ ▄ ▄▄▄ ▄▄▄ ▄▄▄\n3▄ ▄ ▄ ▄▄▄ ▄▄▄\n4▄ ▄ ▄ ▄ ▄▄▄\n5▄ ▄ ▄ ▄ ▄\n6▄▄▄ ▄ ▄ ▄ ▄\n7▄▄▄ ▄▄▄ ▄ ▄ ▄\n8▄▄▄ ▄▄▄ ▄▄▄ ▄ ▄\n9▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄\nVariants:\nMorse Decoder\nRosetta Code,\nWikipedia\nCopy as JSON\nCopied",
    "solution": "import sys\ndef morse_encode(text):\n MORSE_CODE_DICT={'A':'▄ ▄▄▄','B':'▄▄▄ ▄ ▄ ▄','C':'▄▄▄ ▄ ▄▄▄ ▄','D':'▄▄▄ ▄ ▄','E':'▄','F':'▄ ▄ ▄▄▄ ▄','G':'▄▄▄ ▄▄▄ ▄','H':'▄ ▄ ▄ ▄','I':'▄ ▄','J':'▄ ▄▄▄ ▄▄▄ ▄▄▄','K':'▄▄▄ ▄ ▄▄▄','L':'▄ ▄▄▄ ▄ ▄','M':'▄▄▄ ▄▄▄','N':'▄▄▄ ▄','O':'▄▄▄ ▄▄▄ ▄▄▄','P':'▄ ▄▄▄ ▄▄▄ ▄','Q':'▄▄▄ ▄▄▄ ▄ ▄▄▄','R':'▄ ▄▄▄ ▄','S':'▄ ▄ ▄','T':'▄▄▄','U':'▄ ▄ ▄▄▄','V':'▄ ▄ ▄ ▄▄▄','W':'▄ ▄▄▄ ▄▄▄','X':'▄▄▄ ▄ ▄ ▄▄▄','Y':'▄▄▄ ▄ ▄▄▄ ▄▄▄','Z':'▄▄▄ ▄▄▄ ▄ ▄','0':'▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄','1':'▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄','2':'▄ ▄ ▄▄▄ ▄▄▄ ▄▄▄','3':'▄ ▄ ▄ ▄▄▄ ▄▄▄','4':'▄ ▄ ▄ ▄ ▄▄▄','5':'▄ ▄ ▄ ▄ ▄','6':'▄▄▄ ▄ ▄ ▄ ▄','7':'▄▄▄ ▄▄▄ ▄ ▄ ▄','8':'▄▄▄ ▄▄▄ ▄▄▄ ▄ ▄','9':'▄▄▄ ▄▄▄ ▄▄▄ ▄▄▄ ▄',' ':' '}\n encoded_words=[]\n for word in text.split(' '):\n  encoded_letters=[]\n  for char in word.upper():\n   if char in MORSE_CODE_DICT:encoded_letters.append(MORSE_CODE_DICT[char])\n  encoded_words.append('   '.join(encoded_letters))\n return '          '.join(encoded_words)\nif __name__=='__main__':\n if len(sys.argv)>1:\n  for arg in sys.argv[1:]:print(morse_encode(arg))"
  },
  {
    "id": "musical-chords",
    "description": "For each set of three musical notes forming a triad, print the name of the\nchord they form, consisting of the root note and the type of triad.\nEach note is represented as an uppercase letter, optionally followed by a\nsingle accidental, either sharp (♯ U+266F) or flat (♭ U+266D).\nBackground:\nThere are twelve pitch classes in twelve-tone equal temperament, some of\nwhich have multiple names due to ♯ and ♭ raising and\nlowering the pitch, respectively. They are, in ascending order:\n#\nName 1\nName 2\n0\nA\n1\nA♯\nB♭\n2\nB\nC♭\n3\nC\nB♯\n4\nC♯\nD♭\n5\nD\n6\nD♯\nE♭\n7\nE\nF♭\n8\nF\nE♯\n9\nF♯\nG♭\n10\nG\n11\nG♯\nA♭\nA triad consists of a root note on the bottom followed by two thirds\nstacked on top of it. Thirds describe the distance between the preceding\nand following note. A third can be either of two types:\nName\nDistance\nExample\nMinor third\n3\nA C (note 0 to note 3)\nMajor third\n4\nC E (note 3 to note 7)\nBeing that there are 2 thirds in a triad and each third can be of 2\ndifferent types, there are 4 total “types” of triads. They are:\nTriad Name\nThirds (Bottom to Top)\nExample\nDiminished Triad\nMinor, Minor\nB D F\nMinor Triad\nMinor, Major\nE G B\nMajor Triad\nMajor, Minor\nC E G\nAugmented Triad\nMajor, Major\nD F♯ A♯\nInput:\nTriads of notes will always be written out so that the letters in the\nname used ascend by 2 between each third (wrapping back to A after G).\nTherefore, a triad consisting of notes 3, 6, and 9 may be written as\nB♯ D♯ F♯ or C E♭ G♭, but not, for example, as\nC D♯ F♯.\nThe notes may appear in any order, e.g., C E G and E C G\nboth may appear.\nOutput:\nChords are named by the root note followed by nothing for major,\nm for minor, ° U+00B0 for diminished, and + for\naugmented.\nThe spelling of the root note in the output must match the input, e.g.\nthe expected output for C E♭ G♭ is C°, not B♯°.\nNote: to find the root, look only at the letters. E G♯ C\nand E G♯ B♯ cannot be told apart by a method that only considers\nnote distances. The root is the note whose letter comes 2 and 4 letters\nbefore the other two letters in the chord. The expected outputs are\nC+ and E+ respectively.\nWikipedia",
    "solution": "import sys\nfrom collections import defaultdict\nnote_to_pitch={'A':0,'A♯':1,'B♭':1,'B':2,'C♭':2,'B♯':3,'C':3,'C♯':4,'D♭':4,'D':5,'D♯':6,'E♭':6,'E':7,'F♭':7,'E♯':8,'F':8,'F♯':9,'G♭':9,'G':10,'G♯':11,'A♭':11}\nletter_index={'A':0,'B':1,'C':2,'D':3,'E':4,'F':5,'G':6}\nchord_types={(3,3):'°',(3,4):'m',(4,3):'',(4,4):'+'}\ndef interval(a,b):return(b-a)%12\ndef is_root(root_letter,others):\n li=sorted((letter_index[c[0]]-letter_index[root_letter])%7 for c in others)\n return li==[2,4]\ndef main():\n for triad in sys.argv[1:]:\n  notes=triad.strip().split()\n  pitch_map={n:note_to_pitch[n]for n in notes}\n  result=None\n  for root in notes:\n   others=[n for n in notes if n!=root]\n   if is_root(root[0],others):\n    r,o1,o2=root,others[0],others[1]\n    ordered=sorted([(letter_index[n[0]]-letter_index[r[0]])%7,n]for n in[o1,o2])\n    first=ordered[0][1]\n    second=ordered[1][1]\n    i1=interval(pitch_map[r],pitch_map[first])\n    i2=interval(pitch_map[first],pitch_map[second])\n    chord=r+chord_types.get((i1,i2),'?')\n    result=chord\n    break\n  print(result if result else'Unknown')\nif __name__=='__main__':main()"
  },
  {
    "id": "n-queens",
    "description": "In chess, pieces move on a board of 8 ranks and 8 files. A chess queen can\nattack along a file a rank or a diagonal. It is possible to place 8 queens\non the board, such that no queen is under attack by another one. When we\nlist the rank on which the queen is for each file, one solution looks like\nthis:\n63571428\nPrint all solutions to the N queens problem, one per a line, for boards of\nsizes 4-8.\nRosetta Code,\nWikipedia\nThe output judge is order agnostic. The expected output shown is one of many valid outputs.\nCopy Answer\nCopied",
    "solution": "def solve_n_queens(n):\n def backtrack(col,diagonals,anti_diagonals,rows,state):\n  if col==n:solutions.append(''.join(str(r+1)for r in state));return\n  for row in range(n):\n   if row in rows or(row-col)in diagonals or(row+col)in anti_diagonals:continue\n   rows.add(row);diagonals.add(row-col);anti_diagonals.add(row+col);state.append(row)\n   backtrack(col+1,diagonals,anti_diagonals,rows,state)\n   rows.remove(row);diagonals.remove(row-col);anti_diagonals.remove(row+col);state.pop()\n solutions=[]\n backtrack(0,set(),set(),set(),[])\n return solutions\nfor n in range(4,9):\n for sol in solve_n_queens(n):print(sol)"
  },
  {
    "id": "niven-numbers",
    "description": "A Niven number is a positive integer that is divisible by the sum of\nits digits.\nPrint all the Niven numbers from 1 to\n100\ninclusive, each on their own line.\nVariants:\nNiven Numbers (Long)\nOEIS A005349,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_niven(num):\n  \"\"\"\n  Checks if a number is a Niven number.\n\n  Args:\n    num: The number to check.\n\n  Returns:\n    True if the number is a Niven number, False otherwise.\n  \"\"\"\n  num_str = str(num)\n  digit_sum = sum(int(digit) for digit in num_str)\n\n  if digit_sum == 0:\n      return False\n\n  return num % digit_sum == 0\n\n\ndef print_niven_numbers(limit):\n  \"\"\"\n  Prints all Niven numbers from 1 to the given limit (inclusive).\n\n  Args:\n    limit: The upper limit for finding Niven numbers.\n  \"\"\"\n  for i in range(1, limit + 1):\n    if is_niven(i):\n      print(i)\n\nif __name__ == \"__main__\":\n  print_niven_numbers(100)"
  },
  {
    "id": "niven-numbers-long",
    "description": "A Niven number is a positive integer that is divisible by the sum of\nits digits.\nPrint all the Niven numbers from 1 to\n10,000\ninclusive, each on their own line.\nVariants:\nNiven Numbers\nOEIS A005349,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_niven(num):\n    \"\"\"\n    Checks if a number is a Niven number.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is a Niven number, False otherwise.\n    \"\"\"\n    num_str = str(num)\n    digit_sum = sum(int(digit) for digit in num_str)\n    if digit_sum == 0:  # Handle the case where digit_sum is zero to avoid division by zero\n        return False\n    return num % digit_sum == 0\n\n\ndef find_niven_numbers(limit):\n    \"\"\"\n    Prints all Niven numbers from 1 to the given limit, inclusive.\n\n    Args:\n        limit: The upper limit for finding Niven numbers.\n    \"\"\"\n    for i in range(1, limit + 1):\n        if is_niven(i):\n            print(i)\n\n\nif __name__ == \"__main__\":\n    find_niven_numbers(10000)"
  },
  {
    "id": "number-spiral",
    "description": "Print a 10×10 grid of the numbers 0 to 99 inclusive.\nStarting at the top left the numbers should spiral clockwise towards the\ncentre, be right aligned, and have a space between each number.\nThe full grid should look like this:\n0  1  2  3  4  5  6  7  8  9\n35 36 37 38 39 40 41 42 43 10\n34 63 64 65 66 67 68 69 44 11\n33 62 83 84 85 86 87 70 45 12\n32 61 82 95 96 97 88 71 46 13\n31 60 81 94 99 98 89 72 47 14\n30 59 80 93 92 91 90 73 48 15\n29 58 79 78 77 76 75 74 49 16\n28 57 56 55 54 53 52 51 50 17\n27 26 25 24 23 22 21 20 19 18\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def spiral_grid(n):\n    \"\"\"\n    Generates and prints a spiral grid of numbers from 0 to n*n - 1.\n\n    Args:\n        n: The size of the grid (n x n).\n    \"\"\"\n\n    grid = [[0] * n for _ in range(n)]\n    num = 0\n    top, bottom = 0, n - 1\n    left, right = 0, n - 1\n    direction = 0  # 0: right, 1: down, 2: left, 3: up\n\n    while top <= bottom and left <= right:\n        if direction == 0:  # right\n            for i in range(left, right + 1):\n                grid[top][i] = num\n                num += 1\n            top += 1\n        elif direction == 1:  # down\n            for i in range(top, bottom + 1):\n                grid[i][right] = num\n                num += 1\n            right -= 1\n        elif direction == 2:  # left\n            for i in range(right, left - 1, -1):\n                grid[bottom][i] = num\n                num += 1\n            bottom -= 1\n        elif direction == 3:  # up\n            for i in range(bottom, top - 1, -1):\n                grid[i][left] = num\n                num += 1\n            left += 1\n\n        direction = (direction + 1) % 4\n\n    for row in grid:\n        for val in row:\n            print(f\"{val:>2}\", end=\" \")\n        print()\n\nif __name__ == \"__main__\":\n    spiral_grid(10)"
  },
  {
    "id": "odious-numbers",
    "description": "An odious number is a non-negative number that has an odd number of 1s in\nits binary expansion.\nPrint all the odious numbers from 0 to\n50\ninclusive, each on their own line.\nVariants:\nEvil Numbers,\nEvil Numbers (Long),\nOdious Numbers (Long)\nOEIS A000069,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_odious(n):\n  \"\"\"\n  Checks if a number is odious.\n\n  An odious number is a non-negative number that has an odd number of 1s in\n  its binary expansion.\n\n  Args:\n    n: The number to check.\n\n  Returns:\n    True if the number is odious, False otherwise.\n  \"\"\"\n  binary_representation = bin(n)[2:]  # Convert to binary string and remove \"0b\" prefix\n  count_of_ones = binary_representation.count('1')\n  return count_of_ones % 2 != 0\n\n\nif __name__ == \"__main__\":\n  for i in range(51):\n    if is_odious(i):\n      print(i)"
  },
  {
    "id": "odious-numbers-long",
    "description": "An odious number is a non-negative number that has an odd number of 1s in\nits binary expansion.\nPrint all the odious numbers from 0 to\n1,000\ninclusive, each on their own line.\nVariants:\nEvil Numbers,\nEvil Numbers (Long),\nOdious Numbers\nOEIS A000069,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_odious(n):\n  \"\"\"\n  Checks if a number is odious (has an odd number of 1s in its binary representation).\n\n  Args:\n    n: The non-negative integer to check.\n\n  Returns:\n    True if the number is odious, False otherwise.\n  \"\"\"\n  binary_representation = bin(n)[2:]  # Convert to binary and remove \"0b\" prefix\n  count_of_ones = binary_representation.count('1')\n  return count_of_ones % 2 != 0\n\n\ndef print_odious_numbers(limit):\n  \"\"\"\n  Prints all odious numbers from 0 to limit (inclusive).\n\n  Args:\n    limit: The upper limit (inclusive) for finding odious numbers.\n  \"\"\"\n  for i in range(limit + 1):\n    if is_odious(i):\n      print(i)\n\n\nif __name__ == \"__main__\":\n  print_odious_numbers(1000)"
  },
  {
    "id": "ordinal-numbers",
    "description": "For each integer argument, print the argument and its ordinal suffix\n(e.g. 1st, 2nd, 3rd, 112th).\nThe integers will be in the range of 0 to 999 inclusive.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef ordinal(n):\n if 11<=(n%100)<=13:suffix=\"th\"\n else:suffix={1:\"st\",2:\"nd\",3:\"rd\"}.get(n%10,\"th\")\n return f\"{n}{suffix}\"\ndef main():\n for arg in sys.argv[1:]:\n  try:\n   n=int(arg)\n   if 0<=n<=999:print(ordinal(n))\n   else:print(f\"Error: {n} is out of range (0-999)\")\n  except ValueError:print(f\"Error: '{arg}' is not a valid integer\")\nif __name__=='__main__':main()"
  },
  {
    "id": "palindromemordnilap",
    "description": "Given an alphanumeric string, append minimum number of characters to get a\npalindrome and output the result.\nFor example, on input Palindromemord, output\nPalindromemordnilaP.",
    "solution": "import sys\ndef make_palindrome(s):\n r=s[::-1]\n for k in range(len(s),-1,-1):\n  cand=s+r[k:]\n  if cand==cand[::-1]:return cand\n return s+r\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py str1 [str2 ...]\");return\n for s in sys.argv[1:]:print(make_palindrome(s))\nif __name__=='__main__':main()"
  },
  {
    "id": "pangram-grep",
    "description": "A pangram is a sentence that uses every letter of a given alphabet.\nWrite a program that will receive various sentences as arguments and print\nthose that are valid pangrams, meaning they use all letters from A to Z,\ncase insensitive.\nRosetta Code,\nWikipedia",
    "solution": "import sys\n\ndef is_pangram(sentence):\n    \"\"\"\n    Checks if a sentence is a pangram (contains all letters from A to Z, case-insensitive).\n\n    Args:\n        sentence: The sentence to check.\n\n    Returns:\n        True if the sentence is a pangram, False otherwise.\n    \"\"\"\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    sentence = sentence.lower()\n    letters_present = set()\n    for char in sentence:\n        if 'a' <= char <= 'z':\n            letters_present.add(char)\n    return letters_present == alphabet\n\nif __name__ == \"__main__\":\n    sentences = sys.argv[1:]  # Get sentences from command line arguments\n\n    for sentence in sentences:\n        if is_pangram(sentence):\n            print(sentence)"
  },
  {
    "id": "partition-numbers",
    "description": "The nth partition number is the number of ways that n can be\nexpressed as the sum of positive integers, where ordering does not matter.\nFor example, 4 can be partitioned in five distinct ways:\n4\n3 + 1\n2 + 2\n1 + 2 + 1\n1 + 1 + 1 + 1\nPrint the first 100 partition numbers, each on a separate line.\nOEIS A000041,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def partition_numbers(n):\n p=[1]+[0]*n\n for k in range(1,n+1):\n  for i in range(k,n+1):p[i]+=p[i-k]\n return p\np=partition_numbers(99)\nfor i,val in enumerate(p):print(val)"
  },
  {
    "id": "pascals-triangle",
    "description": "Pascal’s triangle is a triangular pattern of integers formed by the\nbinomial coefficients.\nPrint the first 20 rows of Pascal’s triangle.\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def pascal_triangle(rows):\n triangle=[[1]]\n for i in range(1,rows):\n  prev=triangle[-1]\n  row=[1]+[prev[j]+prev[j+1]for j in range(len(prev)-1)]+[1]\n  triangle.append(row)\n return triangle\nfor row in pascal_triangle(20):print(' '.join(map(str,row)))"
  },
  {
    "id": "pernicious-numbers",
    "description": "A pernicious number is a positive number where the sum of its binary\nexpansion is a prime number.\nFor example, 5 is a pernicious number since\n5 = 1012 and 1 + 1 = 2, which is prime.\nPrint all the pernicious numbers from 0 to\n50\ninclusive, each on their own line.\nVariants:\nPernicious Numbers (Long)\nOEIS A052294,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_set_bits(n):\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a number.\n    \"\"\"\n    count = 0\n    while (n > 0):\n        n &= (n - 1)\n        count += 1\n    return count\n\nif __name__ == \"__main__\":\n    for i in range(0, 51):\n        set_bits = count_set_bits(i)\n        if is_prime(set_bits):\n            print(i)"
  },
  {
    "id": "pernicious-numbers-long",
    "description": "A pernicious number is a positive number where the sum of its binary\nexpansion is a prime number.\nFor example, 5 is a pernicious number since\n5 = 1012 and 1 + 1 = 2, which is prime.\nPrint all the pernicious numbers from 0 to\n10,000\ninclusive, each on their own line.\nVariants:\nPernicious Numbers\nOEIS A052294,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_set_bits(n):\n    \"\"\"\n    Counts the number of set bits (1s) in the binary representation of a number.\n    \"\"\"\n    count = 0\n    while (n > 0):\n        n &= (n - 1)\n        count += 1\n    return count\n\ndef find_pernicious_numbers(limit):\n    \"\"\"\n    Prints all pernicious numbers from 0 to limit inclusive.\n    \"\"\"\n    for i in range(limit + 1):\n        set_bits = count_set_bits(i)\n        if is_prime(set_bits):\n            print(i)\n\nif __name__ == \"__main__\":\n    find_pernicious_numbers(10000)"
  },
  {
    "id": "poker",
    "description": "Given various poker hands as arguments, print what type of hand each\nargument is.\nThe list of hands in ranking order are as follows:\nHand\nCards\nDescription\nRoyal Flush\n🃁🃎🃍🃋🃊\nTen to Ace of the same suit\nStraight Flush\n🃛🃚🃙🃘🃗\nFive consecutive cards of the same suit\nFour of a Kind\n🃕🃅🂵🂥🃂\nFour cards of the same rank\nFull House\n🂦🂶🃆🃞🂾\nThree of a Kind combined with a Pair\nFlush\n🃋🃉🃈🃄🃃\nFive cards of the same suit\nStraight\n🃊🂩🂸🃇🃖\nFive consecutive cards\nThree of a Kind\n🃝🂭🂽🂹🂢\nThree cards of the same rank\nTwo Pair\n🂻🂫🃓🂣🂲\nTwo separate pairs\nPair\n🂪🂺🂨🂷🃔\nTwo cards of the same rank\nHigh Card\n🃎🃍🂧🂤🂳\nNo other hand applies\nRosetta Code,\nWikipedia",
    "solution": "import sys\nfrom collections import Counter\nUNICODE_MAP={'🂡':'A','🂢':'2','🂣':'3','🂤':'4','🂥':'5','🂦':'6','🂧':'7','🂨':'8','🂩':'9','🂪':'T','🂫':'J','🂭':'Q','🂮':'K','🂵':'5','🂱':'A','🂲':'2','🂳':'3','🂴':'4','🂵':'5','🂶':'6','🂷':'7','🂸':'8','🂹':'9','🂺':'T','🂻':'J','🂽':'Q','🂾':'K','🂿':'A','🃁':'A','🃂':'2','🃃':'3','🃄':'4','🃅':'5','🃆':'6','🃇':'7','🃈':'8','🃉':'9','🃊':'T','🃋':'J','🃍':'Q','🃎':'K','🃑':'A','🃒':'2','🃓':'3','🃔':'4','🃕':'5','🃖':'6','🃗':'7','🃘':'8','🃙':'9','🃚':'T','🃛':'J','🃝':'Q','🃞':'K','🂺':'T','🃚':'T','🃊':'T','🂪':'T'}\ndef parse_hand(hand_str):\n ranks_chars=[];suits=[]\n for card_char in hand_str:\n  if card_char in UNICODE_MAP:\n   ranks_chars.append(UNICODE_MAP[card_char])\n   code_point=ord(card_char)\n   if 0x1F0A0<=code_point<=0x1F0AF:suits.append('♠')\n   elif 0x1F0B0<=code_point<=0x1F0BF:suits.append('♥')\n   elif 0x1F0C0<=code_point<=0x1F0CF:suits.append('♦')\n   elif 0x1F0D0<=code_point<=0x1F0DF:suits.append('♣')\n  else:return[],[]\n ranks_values=[]\n for char in ranks_chars:\n  if char=='A':ranks_values.append(14)\n  elif char=='K':ranks_values.append(13)\n  elif char=='Q':ranks_values.append(12)\n  elif char=='J':ranks_values.append(11)\n  elif char=='T':ranks_values.append(10)\n  else:ranks_values.append(int(char))\n return ranks_values,suits\ndef get_hand_type(hand_str):\n ranks,suits=parse_hand(hand_str)\n if len(ranks)!=5:return\"Invalid Hand\"\n ranks.sort()\n is_flush=len(set(suits))==1\n is_straight=False\n if ranks==[2,3,4,5,14]:is_straight=True;ranks_for_straight=[1,2,3,4,5]\n elif len(set(ranks))==5 and ranks[4]-ranks[0]==4:is_straight=True;ranks_for_straight=ranks\n else:ranks_for_straight=ranks\n rank_counts=Counter(ranks);counts=sorted(rank_counts.values(),reverse=True)\n if is_flush and is_straight:\n  if ranks_for_straight==[10,11,12,13,14]:return\"Royal Flush\"\n  else:return\"Straight Flush\"\n elif counts==[4,1]:return\"Four of a Kind\"\n elif counts==[3,2]:return\"Full House\"\n elif is_flush:return\"Flush\"\n elif is_straight:return\"Straight\"\n elif counts==[3,1,1]:return\"Three of a Kind\"\n elif counts==[2,2,1]:return\"Two Pair\"\n elif counts==[2,1,1,1]:return\"Pair\"\n else:return\"High Card\"\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py \\\"hand1\\\" \\\"hand2\\\" ...\");sys.exit(1)\n for hand_str in sys.argv[1:]:print(get_hand_type(hand_str))\nif __name__=='__main__':main()"
  },
  {
    "id": "polyominoes",
    "description": "A polyomino is a 2D shape formed by joining squares along common edges, such\nthat all squares are connected. Output each possible polyomino (including\nevery rotation), up to a size of 6, in any order. Separate each polyomino by\nan empty line.\nThere should be a total of 1 monomino, 2 dominoes, 6 trominoes,\n19 tetrominoes, 63 pentominoes, and 216 hexominoes.\nWikipedia\nThe output judge is order agnostic. The expected output shown is one of many valid outputs.\nCopy Answer\nCopied",
    "solution": "import sys\nfrom collections import deque\ndef normalize_polyomino(polyomino):\n min_x=min(x for x,y in polyomino)\n min_y=min(y for x,y in polyomino)\n return frozenset((x-min_x,y-min_y)for x,y in polyomino)\ndef get_all_rotations(polyomino):\n rotations=set()\n current=polyomino\n for _ in range(4):\n  rotations.add(current)\n  current=frozenset((-y,x)for x,y in current)\n return rotations\ndef print_polyomino(polyomino):\n if not polyomino:return\n min_x=min(x for x,y in polyomino)\n max_x=max(x for x,y in polyomino)\n min_y=min(y for x,y in polyomino)\n max_y=max(y for x,y in polyomino)\n width=max_x-min_x+1\n height=max_y-min_y+1\n grid=[[' 'for _ in range(width)]for _ in range(height)]\n for x,y in polyomino:grid[y-min_y][x-min_x]='#'\n for row in grid:print(''.join(row))\ndef main():\n sys.setrecursionlimit(2000)\n all_polyominoes=[[],[],[],[],[],[],[]]\n polyomino_set={frozenset([(0,0)])}\n all_polyominoes[1]=polyomino_set\n for size in range(2,7):\n  new_polyominoes=set()\n  for polyomino in all_polyominoes[size-1]:\n   for x,y in polyomino:\n    for dx,dy in[(0,1),(0,-1),(1,0),(-1,0)]:\n     new_square=(x+dx,y+dy)\n     if new_square not in polyomino:\n      new_polyomino=polyomino.union({new_square})\n      new_polyominoes.add(normalize_polyomino(new_polyomino))\n  all_polyominoes[size]=new_polyominoes\n for size in range(1,7):\n  printed_polys=set()\n  for canonical_polyomino in all_polyominoes[size]:\n   all_rotations=get_all_rotations(canonical_polyomino)\n   for rotation in all_rotations:\n    normalized_rotation=normalize_polyomino(rotation)\n    if normalized_rotation not in printed_polys:\n     print_polyomino(normalized_rotation)\n     print()\n     printed_polys.add(normalized_rotation)\nif __name__=='__main__':main()"
  },
  {
    "id": "prime-numbers",
    "description": "Print all the prime numbers from 1 to\n100\ninclusive, each on their own line.\nVariants:\nPrime Numbers (Long)\nOEIS A000040,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import math\n\ndef is_prime(n):\n  \"\"\"\n  Checks if a number is prime.\n\n  Args:\n    n: The number to check.\n\n  Returns:\n    True if the number is prime, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return False\n  for i in range(2, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n      return False\n  return True\n\ndef print_primes(limit):\n  \"\"\"\n  Prints all prime numbers from 1 to limit (inclusive), each on a new line.\n\n  Args:\n    limit: The upper limit of the range.\n  \"\"\"\n  for i in range(2, limit + 1):\n    if is_prime(i):\n      print(i)\n\nif __name__ == \"__main__\":\n  print_primes(100)"
  },
  {
    "id": "prime-numbers-long",
    "description": "Print all the prime numbers from 1 to\n10,000\ninclusive, each on their own line.\nVariants:\nPrime Numbers\nOEIS A000040,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def is_prime(n):\n    \"\"\"\n    Check if a number is prime.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef print_primes(limit):\n    \"\"\"\n    Print all prime numbers from 1 to limit inclusive, each on their own line.\n\n    Args:\n        limit: The upper limit for prime number generation.\n    \"\"\"\n    for i in range(2, limit + 1):\n        if is_prime(i):\n            print(i)\n\nif __name__ == \"__main__\":\n    print_primes(10000)"
  },
  {
    "id": "proximity-grid",
    "description": "A grid is a 9x9 square of characters representing an arrangement of points,\nsome of which are walls, denoted by #'s, or sources, denoted by 0's; every\nother point is passible, denoted with -'s.\nFor a series of grids, compute the length of the shortest path connecting\neach passible point to a source. A path must move horizontally or\nvertically through the grid and cannot pass through walls. Output each\ngrid with every passible point replaced by its distance to a source\nwritten in base62 (0-9 A-Z a-z); points which cannot be connected to a\nsource should remain unchanged.\nWikipedia",
    "solution": "import sys\nfrom collections import deque\nBASE62_CHARS=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\ndef to_base62(n):\n if n==0:return BASE62_CHARS[0]\n s=\"\"\n while n>0:s=BASE62_CHARS[n%62]+s;n//=62\n return s\ndef solve_grid(grid_input):\n rows,cols=9,9\n grid=[list(row)for row in grid_input.split('\\n')]\n distances=[[-1]*cols for _ in range(rows)]\n queue=deque()\n for r in range(rows):\n  for c in range(cols):\n   if grid[r][c]=='0':distances[r][c]=0;queue.append((r,c))\n while queue:\n  r,c=queue.popleft()\n  for dr,dc in[(0,1),(0,-1),(1,0),(-1,0)]:\n   nr,nc=r+dr,c+dc\n   if 0<=nr<rows and 0<=nc<cols and grid[nr][nc]=='-' and distances[nr][nc]==-1:\n    distances[nr][nc]=distances[r][c]+1\n    queue.append((nr,nc))\n output_grid=[list(row)for row in grid_input.split('\\n')]\n for r in range(rows):\n  for c in range(cols):\n   if distances[r][c]>0:output_grid[r][c]=to_base62(distances[r][c])\n return[\"\".join(row)for row in output_grid]\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py \\\"grid1\\\" \\\"grid2\\\" ...\");sys.exit(1)\n for i,grid_arg in enumerate(sys.argv[1:]):\n  if i>0:print()\n  result_grid=solve_grid(grid_arg)\n  for line in result_grid:print(line)\nif __name__=='__main__':main()"
  },
  {
    "id": "qr-decoder(Error)",
    "description": "Decode a Version-1 QR code given in this ASCII-art format, where all the\nv and ^ are filled with \"#\" and spaces, encoding\na message.\n#######  vv^^ #######\n#     #  vv^^ #     #\n# ### # #vv^^ # ### #\n# ### #  vv^^ # ### #\n# ### #  vv^^ # ### #\n#     #  vv^^ #     #\n####### # # # #######\n#vv^^\n### #####vv^^##   #\nvv^^vv ^^vv^^vv^^vv^^\nvv^^vv#^^vv^^vv^^vv^^\nvv^^vv ^^vv^^vv^^vv^^\nvv^^vv#^^vv^^vv^^vv^^\n#vv^^vv^^vv^^\n####### #vv^^vv^^vv^^\n#     # #vv^^vv^^vv^^\n# ### # #vv^^vv^^vv^^\n# ### #  vv^^vv^^vv^^\n# ### # #vv^^vv^^vv^^\n#     # #vv^^vv^^vv^^\n####### #vv^^vv^^vv^^\nThe 10 vertical \"strips\" of ^^ or vv must be\nread from right to left. The bits in a strip are stored in a zig-zag\norder: ^^ zig-zags upwards, and vv zig-zags\ndownwards. The bit on the right always precedes the one on its left.\n^^ ..    vv 10\n^^ 98    vv 32\n^^ 76    vv 54\n^^ 54    vv 76\n^^ 32    vv 98\n^^ 10    vv ..\nTo decode a bit off of a strip, read the value from the QR code bitmap\n(\"#\" = 1, space = 0) and invert it if (x+y)%2 = 0, where\n(x, y) are the coordinates of the bit in the bitmap with the origin\n(0, 0) at the top-left corner.\nThis will yield a bitstream like:\n0100  00010001  01001000  01100101  01101100 ...\nEnc   Length    'H'       'e'       'l'\n(4)   (17)      (17-byte ASCII message)\nPrint the 17 bytes of ASCII stored in the QR code.\nWikipedia",
    "solution": "def decode_qr(qr_code):\n    \"\"\"Decodes a Version-1 QR code from an ASCII-art representation.\"\"\"\n\n    def extract_bits(qr_code):\n        \"\"\"Extracts bits from the QR code based on 'vv' and '^^' patterns.\"\"\"\n        bits = []\n        height = len(qr_code)\n        width = len(qr_code[0])\n\n        for strip_index in range(10):\n            # Process each strip from right to left\n            x = width - 8 - strip_index  # Calculate x-coordinate\n\n            # Zig-zag upwards (^^)\n            for y in range(height - 1, -1, -1):  # Start from the bottom\n                if qr_code[y][x] == '^':\n                    bit = 1 if qr_code[y][x] == '#' else 0\n                    if (x + y) % 2 == 0:\n                        bit = 1 - bit  # Invert the bit\n                    bits.append(bit)\n\n            # Zig-zag downwards (vv)\n            for y in range(0, height):  # Start from the top\n                if qr_code[y][x] == 'v':\n                    bit = 1 if qr_code[y][x] == '#' else 0\n                    if (x + y) % 2 == 0:\n                        bit = 1 - bit  # Invert the bit\n                    bits.append(bit)\n\n        return bits\n\n    def bits_to_bytes(bits):\n        \"\"\"Converts a list of bits to a list of bytes.\"\"\"\n        byte_string = \"\"\n        for bit in bits:\n            byte_string += str(bit)\n\n        byte_list = []\n        for i in range(0, len(byte_string), 8):\n            byte = byte_string[i:i+8]\n            byte_list.append(int(byte, 2))\n        return byte_list\n\n    # Extract bits\n    bits = extract_bits(qr_code)\n\n    # Convert bits to bytes\n    byte_list = bits_to_bytes(bits)\n    \n    # Extract relevant information\n    encoding_type = bin(byte_list[0])[2:].zfill(8)[:4] #First byte contains encoding and length\n    length = bin(byte_list[0])[2:].zfill(8)[4:] + bin(byte_list[1])[2:].zfill(8)[2:]\n    \n    # Extract the 17 bytes message.\n    message_bytes = byte_list[2:19]\n    \n    #Convert bytes to chars and return the message\n    message = ''.join(chr(byte) for byte in message_bytes)\n    \n    return message\n\n# Example Usage:\nqr_code_data = [\n    \"#######  vv^^ #######\",\n    \"#     #  vv^^ #     #\",\n    \"# ### # #vv^^ # ### #\",\n    \"# ### #  vv^^ # ### #\",\n    \"# ### #  vv^^ # ### #\",\n    \"#     #  vv^^ #     #\",\n    \"####### # # # #######\",\n    \"#vv^^                \",\n    \"### #####vv^^##   #\",\n    \"vv^^vv ^^vv^^vv^^vv^^\",\n    \"vv^^vv#^^vv^^vv^^vv^^\",\n    \"vv^^vv ^^vv^^vv^^vv^^\",\n    \"vv^^vv#^^vv^^vv^^vv^^\",\n    \"#vv^^vv^^vv^^        \",\n    \"####### #vv^^vv^^vv^^\",\n    \"#     # #vv^^vv^^vv^^\",\n    \"# ### # #vv^^vv^^vv^^\",\n    \"# ### #  vv^^vv^^vv^^\",\n    \"# ### # #vv^^vv^^vv^^\",\n    \"#     # #vv^^vv^^vv^^\",\n    \"####### #vv^^vv^^vv^^\"\n]\n\n# Replace 'v' and '^' with '#' and ' ' for proper bit extraction.\nmodified_qr_code = []\nfor row in qr_code_data:\n    modified_row = row.replace('v', '#').replace('^', ' ')\n    modified_qr_code.append(modified_row)\n\ndecoded_message = decode_qr(modified_qr_code)\nprint(decoded_message)"
  },
  {
    "id": "quine",
    "description": "A quine is a non-empty computer program which takes no input and\nproduces a copy of its own source code as its only output. Produce such a\nprogram.\nTrailing whitespace is NOT stripped from the output for this hole.\n(Consequently, if your submission doesn't pass, try adding a line break at\nthe end.)\nRosetta Code,\nWikipedia",
    "solution": "s = 's = %r\nprint(s %% s)'\nprint(s % s)\n"
  },
  {
    "id": "recamán",
    "description": "Starting from a(0) = 0, each term of the sequence is\na(n) = a(n-1) − n but only if a(n) > 0 and it has not\npreviously generated. In case the condition doesn't hold,\na(n) = a(n-1) + n.\nPrint the first 250 terms of the sequence one per line.\nNumberphile,\nOEIS A005132,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def generate_sequence(length=250):\n    \"\"\"\n    Generates a sequence based on the described rules and prints the first 'length' terms.\n\n    Args:\n        length: The number of terms to generate.  Defaults to 250.\n    \"\"\"\n\n    sequence = [0]\n    generated_numbers = {0}  # Use a set for efficient membership testing\n\n    for n in range(1, length):\n        minus_n = sequence[-1] - n\n        if minus_n > 0 and minus_n not in generated_numbers:\n            sequence.append(minus_n)\n            generated_numbers.add(minus_n)\n        else:\n            plus_n = sequence[-1] + n\n            sequence.append(plus_n)\n            generated_numbers.add(plus_n)\n\n    for term in sequence:\n        print(term)\n\nif __name__ == \"__main__\":\n    generate_sequence()"
  },
  {
    "id": "repeating-decimals",
    "description": "For each fraction argument a/b, print its decimal expansion.\nIf the decimal expands infinitely, print the finite part followed by the\nrepeating part in parenthesis.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef get_decimal_expansion(numerator,denominator):\n if denominator==0:return\"Error: Division by zero\"\n sign=\"\"\n if(numerator<0)!=(denominator<0):sign=\"-\"\n numerator=abs(numerator)\n denominator=abs(denominator)\n integer_part=str(numerator//denominator)\n remainder=numerator%denominator\n if remainder==0:return sign+integer_part\n seen_remainders={}\n decimal_parts=[]\n index=0\n while remainder!=0 and remainder not in seen_remainders:\n  seen_remainders[remainder]=index\n  remainder*=10\n  decimal_parts.append(str(remainder//denominator))\n  remainder%=denominator\n  index+=1\n if remainder==0:return sign+integer_part+\".\"+\"\".join(decimal_parts)\n else:\n  start_of_repeat=seen_remainders[remainder]\n  non_repeating=\"\".join(decimal_parts[:start_of_repeat])\n  repeating=\"\".join(decimal_parts[start_of_repeat:])\n  return f\"{sign}{integer_part}.{non_repeating}({repeating})\"\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py a/b c/d ...\");sys.exit(1)\n for arg in sys.argv[1:]:\n  try:\n   numerator_str,denominator_str=arg.split('/')\n   numerator=int(numerator_str)\n   denominator=int(denominator_str)\n   result=get_decimal_expansion(numerator,denominator)\n   print(result)\n  except ValueError:print(f\"Error: Invalid argument format '{arg}'\")\n  except IndexError:print(f\"Error: Invalid argument format '{arg}'\")\nif __name__=='__main__':main()"
  },
  {
    "id": "reverse-polish-notation",
    "description": "RPN (Reverse Polish Notation) is a way of writing\nexpressions such that operators are written after their operands:\n3 2 + rather than (3+2).\nEach argument is an RPN expression, given as a space-separated list of\ntokens: either a number 0…32767 or an operator\n(addition +, subtraction -, multiplication\n* or integer division /).\nEvaluate and print the result of each expression on its own line.\nThe result of each operation is a non-negative integer not exceeding\n32,767. Division is guaranteed to have an exact integer result.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef evaluate_rpn(expression):\n stack=[]\n tokens=expression.split()\n for token in tokens:\n  if token.isdigit():stack.append(int(token))\n  else:\n   operand2=stack.pop()\n   operand1=stack.pop()\n   if token=='+':result=operand1+operand2\n   elif token=='-':result=operand1-operand2\n   elif token=='*':result=operand1*operand2\n   elif token=='/':result=operand1//operand2\n   else:raise ValueError(f\"Unknown operator: {token}\")\n   stack.append(result)\n if len(stack)!=1:raise ValueError(\"Invalid RPN expression: more than one value left on stack.\")\n return stack.pop()\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py '3 2 +' '10 5 / 2 *'\");sys.exit(1)\n for arg in sys.argv[1:]:\n  try:\n   result=evaluate_rpn(arg)\n   print(result)\n  except(IndexError,ValueError)as e:print(f\"Error evaluating '{arg}': {e}\",file=sys.stderr)\nif __name__=='__main__':main()"
  },
  {
    "id": "reversi",
    "description": "Output the possible moves for O on a Reversi board.\nIn Reversi, X and O take turns placing tiles on\nempty squares on the board. To determine if a move is legal, draw a\nstraight line in any direction (horizontal, vertical, or diagonal)\nstarting from the square. If the line intersects another friendly tile,\nseparated from the square by only opponent tiles, that square is a legal move.\nFor example, given:\n......\n.OXX!.\n..X...\n...!..\nO can only place on squares marked with !.\nAssume a board size of 8x8 and a position reachable on O's turn,\nfrom the following starting position:\n........\n........\n........\n...OX...\n...XO...\n........\n........\n........\nX moves first, so you may assume an odd number of tiles on the board.\nYour program should output the board with each possible legal O move\nreplaced with !. Each output should be separated by a blank line.\nWikipedia",
    "solution": "import sys\nDIRS=[(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\ndef legal_moves(board):\n n=8\n out=[list(row)for row in board]\n for y in range(n):\n  for x in range(n):\n   if board[y][x]!='.':continue\n   for dy,dx in DIRS:\n    ny,nx=y+dy,x+dx\n    cnt=0\n    while 0<=ny<n and 0<=nx<n and board[ny][nx]=='X':\n     cnt+=1\n     ny+=dy;nx+=dx\n    if cnt>0 and 0<=ny<n and 0<=nx<n and board[ny][nx]=='O':\n     out[y][x]='!'\n     break\n return[\"\".join(row)for row in out]\ndef main():\n args=sys.argv[1:]\n results=[]\n for arg in args:\n  lines=arg.splitlines()\n  if len(lines)!=8:continue\n  board=[line.rstrip()for line in lines]\n  results.extend(legal_moves(board))\n  results.append(\"\")\n if results and results[-1]==\"\":results.pop()\n print(\"\\n\".join(results))\nif __name__=='__main__':main()"
  },
  {
    "id": "rijndael-s-box",
    "description": "Print the Rijndael S-box as a series of hex bytes:\n63 7c 77 7b f2 6b 6f c5 30 01 67 2b fe d7 ab 76\nca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0\nb7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15\n04 c7 23 c3 18 96 05 9a 07 12 80 e2 eb 27 b2 75\n09 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84\n53 d1 00 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf\nd0 ef aa fb 43 4d 33 85 45 f9 02 7f 50 3c 9f a8\n51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2\ncd 0c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73\n60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e 0b db\ne0 32 3a 0a 49 06 24 5c c2 d3 ac 62 91 95 e4 79\ne7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae 08\nba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a\n70 3e b5 66 48 03 f6 0e 61 35 57 b9 86 c1 1d 9e\ne1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df\n8c a1 89 0d bf e6 42 68 41 99 2d 0f b0 54 bb 16\nOEIS A354500,\nWikipedia\nThe output will be checked case-insensitively.\nCopy Answer\nCopied",
    "solution": "sbox=[0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16]\nfor i in range(0,256,16):print(' '.join(f'{b:02x}'for b in sbox[i:i+16]))"
  },
  {
    "id": "rock-paper-scissors-spock-lizard",
    "description": "Judge games of \"rock-paper-scissors\" with additional weapons:\n✂ cuts 📄 covers 💎 crushes 🦎 poisons 🖖 smashes ✂ decapitates 🦎 eats 📄\ndisproves 🖖 vaporizes 💎 crushes ✂.\nEach argument is a string of two emoji encoded in UTF-8. For each argument,\nprint a line like 🦎 poisons 🖖 describing the game outcome,\nor Tie if they are equal.\nThe weapons are represented and encoded as follows:\nWeapon\nEmoji\nCodepoint\nUTF-8 Sequence\nRock\n💎\nU+1F48E\nf0 9f 92 8e\nPaper\n📄\nU+1F4C4\nf0 9f 93 84\nScissors\n✂\nU+2702\ne2 9c 82\nSpock\n🖖\nU+1F596\nf0 9f 96 96\nLizard\n🦎\nU+1F98E\nf0 9f a6 8e\nRules,\nWikipedia",
    "solution": "import sys\nrules={'✂':{'📄':'cuts','🦎':'decapitates'},'📄':{'💎':'covers','🖖':'disproves'},'💎':{'✂':'crushes','🦎':'crushes'},'🦎':{'📄':'eats','🖖':'poisons'},'🖖':{'✂':'smashes','💎':'vaporizes'}}\nfor arg in sys.argv[1:]:\n a,b=arg[0],arg[1]\n if a==b:print(\"Tie\")\n elif b in rules.get(a,{}):print(f\"{a} {rules[a][b]} {b}\")\n else:print(f\"{b} {rules[b][a]} {a}\")"
  },
  {
    "id": "roman-to-arabic",
    "description": "For each numeric argument in Roman numerals, print the same number in\nArabic numerals.\nThe numbers range from 1 to 3999 inclusive.\nArabic\n1\n5\n10\n50\n100\n500\n1000\nRoman\nI\nV\nX\nL\nC\nD\nM\nVariants:\nArabic to Roman\nRosetta Code,\nWikipedia",
    "solution": "import sys\nroman={'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\nfor s in sys.argv[1:]:\n total=0\n for i in range(len(s)):\n  val=roman[s[i]]\n  if i+1<len(s)and roman[s[i]]<roman[s[i+1]]:total-=val\n  else:total+=val\n print(total)"
  },
  {
    "id": "rot13",
    "description": "ROT13, short for rotate by 13 places, is a simple substitution cipher\nderived from the Caesar cipher. It works by replacing each letter in the\nEnglish alphabet with the letter 13 positions after it, wrapping around to\nthe beginning of the alphabet if necessary.\nFor uppercase letters: A becomes N, B becomes\nO, ..., Z becomes M.\nFor lowercase letters: a becomes n, b becomes\no, ..., z becomes m.\nNon-alphabetic characters (digits, punctuation, spaces) remain unchanged.\nHere's a simple table that illustrates each letter substitution with ROT13:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\nNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\nEach argument consists of a sequence of random printable characters from the\nASCII character set.\nFor each argument, print the sequence with all its substitutions after\napplying the appropriate rotations, effectively encoding or decoding the\nsequence, each on their own line.\nRosetta Code,\nWikipedia",
    "solution": "import sys\nfor s in sys.argv[1:]:print(''.join(chr((ord(c)-65+13)%26+65)if c.isupper()else chr((ord(c)-97+13)%26+97)if c.islower()else c for c in s))"
  },
  {
    "id": "rule-110",
    "description": "Print the first 100 rows in the Rule 110 cellular automaton\nstarting from an initial single living cell.\nEach new row in the life of the automaton should be a new line, and the\nrules for whether a cell is alive or dead depends on whether it was alive\non the previous iteration, as well as the state of the two neighbouring\ncells.\nThe rules which dictate whether a cell is alive or dead in the next\niteration are as follows:\nPrevious Cells\nNew Centre Cell\n1110\n1101\n1011\n1000\n0111\n0101\n0011\n0000\nwhere 1 is alive, 0 is dead, and the middle digit represents the previous\nstate of the current cell.\nThe first 10 rows are shown here:\n█\n██\n███\n██ █\n█████\n██   █\n███  ██\n██ █ ███\n███████ █\n██     ███\nWikipedia\nCopy Answer\nCopied",
    "solution": "w=199\na=[0]*w\na[w//2]=1\nfor _ in range(100):\n print(''.join('█'if c else' 'for c in a))\n b=[0]+a+[0]\n a=[int(b[i-1:i+2]in([1,1,0],[1,0,1],[0,1,1],[0,1,0],[0,0,1]))for i in range(1,w+1)]"
  },
  {
    "id": "scrambled-sort",
    "description": "Given a scrambled alphabet and a set of words, print the words in\nalphabetical order according to the given alphabet. Separate the\nwords by spaces for each argument.",
    "solution": "import sys\nfor arg in sys.argv[1:]:\n parts=arg.split()\n alphabet,words=parts[0],parts[1:]\n order={c:i for i,c in enumerate(alphabet)}\n print(' '.join(sorted(words,key=lambda word:[order[c]for c in word])))"
  },
  {
    "id": "set",
    "description": "Set is a card game played with a deck of 81 unique cards that vary in four\nfeatures, each of which takes on three values:\nNumber of shapes: each card contains either 1, 2, or\n3 shapes.\nColor: the shapes on each card are either Red, Green, or\nPurple.\nShading: each shape is either Solid, Half-shaded, or\nEmpty.\nShape: the shapes on each card are either Ovals, Diamonds,\nor Waves.\nA card is represented by the values of its features, with each value encoded\nby its first character. For example, 2RSW means 2\nRed Solid Waves.\nThe goal of the game is to find a set of three cards, such that for\neach of the four features, either all three cards have different values or\nall three cards have the same value. For example, 2RSW,\n2PHW, and 2GEW form a set because they all have\nthe same number and shape, and none of them have the same color or shading.\nArguments consist of twelve cards that are guaranteed to contain exactly one\nset. For each argument, print the contained set with the cards in order of\ntheir appearance separated by spaces, one set per line.\nRosetta Code,\nWikipedia",
    "solution": "import sys\nfrom itertools import combinations\ndef is_set(a,b,c):\n for i in range(4):\n  s={a[i],b[i],c[i]}\n  if len(s)==2:return False\n return True\nfor group in sys.argv[1:]:\n cards=group.split()\n for i,j,k in combinations(range(12),3):\n  if is_set(cards[i],cards[j],cards[k]):print(cards[i],cards[j],cards[k]);break"
  },
  {
    "id": "seven-segment",
    "description": "Using pipes and underscores print the argument as if it were displayed on\na seven segment display.\nFor example the number 0123456789 should be displayed as:\n_     _  _     _  _  _  _  _\n| |  | _| _||_||_ |_   ||_||_|\n|_|  ||_  _|  | _||_|  ||_| _|\nWikipedia",
    "solution": "import sys\ndigits={'0':[' _ ','| |','|_|'],'1':['   ','  |','  |'],'2':[' _ ',' _|','|_ '],'3':[' _ ',' _|',' _|'],'4':['   ','|_|','  |'],'5':[' _ ','|_ ',' _|'],'6':[' _ ','|_ ','|_|'],'7':[' _ ','  |','  |'],'8':[' _ ','|_|','|_|'],'9':[' _ ','|_|',' _|']}\nfor arg in sys.argv[1:]:\n lines=['','','']\n for ch in arg:\n  for i in range(3):lines[i]+=digits[ch][i]\n print('\\n'.join(lines))"
  },
  {
    "id": "si-units(Error)",
    "description": "The International System of Units (SI) defines 7 base units: s\n(second), m (meter), kg (kilogram), A (ampere), K\n(kelvin), mol (mole) and cd (candela). In addition to base units,\nthere are 22 derived units, which can all be represented as products of\npowers of these base units.\nDerived unit\nBase unit equivalent\nrad\t1\nsr\t1\nHz\ts^-1\nN\tkg m s^-2\nPa\tkg m^-1 s^-2\nJ\tkg m^2 s^-2\nDerived unit\nBase unit equivalent\nW\tkg m^2 s^-3\nC\tA s\nV\tkg m^2 s^-3 A^-1\nF\tkg^-1 m^-2 s^4 A^2\nΩ\tkg m^2 s^-3 A^-2\nS\tkg^-1 m^-2 s^3 A^2\nDerived unit\nBase unit equivalent\nWb\tkg m^2 s^-2 A^-1\nT\tkg s^-2 A^-1\nH\tkg m^2 s^-2 A^-2\n°C\tK\nlm\tcd\nlx\tcd m^-2\nDerived unit\nBase unit equivalent\nBq\ts^-1\nGy\tm^2 s^-2\nSv\tm^2 s^-2\nkat\tmol s^-1\nSI also defines 24 symbols known as prefixes, denoting powers of ten.\nSymbol\nFactor\nQ\t10^30\nR\t10^27\nY\t10^24\nZ\t10^21\nE\t10^18\nP\t10^15\nSymbol\nFactor\nT\t10^12\nG\t10^9\nM\t10^6\nk\t10^3\nh\t10^2\nda\t10^1\nSymbol\nFactor\nd\t10^-1\nc\t10^-2\nm\t10^-3\nμ\t10^-6\nn\t10^-9\np\t10^-12\nSymbol\nFactor\nf\t10^-15\na\t10^-18\nz\t10^-21\ny\t10^-24\nr\t10^-27\nq\t10^-30\nEach argument is an SI unit with a possible prefix. Print it as a product of a\npower of ten and its base units. For example, GW (gigawatt) becomes\n10^9 kg m^2 s^-3. Keep in mind the following exceptions:\nThe kilogram is a base unit with an inherent prefix. Other prefixes attach\nto g (gram), and you should print their values relative to the\nkilogram: g is 10^-3 kg and Mg\nis 10^3 kg.\nInstead of 10^1, print 10.\nInstead of 10^0, print 1.\nFor rad and sr, only print a power of ten. (Example: for\nMrad, print 10^6, not 10^6 1.)\nThere is no universal order among the base units. For C, you must\noutput A s rather than s A. We follow the\nconventions of NIST.\nμ is U+03BC GREEK SMALL LETTER MU (UTF-8: ce bc).\nΩ is U+03A9 GREEK CAPITAL LETTER OMEGA (UTF-8: ce a9).\n° is U+00B0 DEGREE SIGN (UTF-8: c2 b0).\nNIST (Prefixes),\nNIST (Units)\nCopy as JSON\nCopied",
    "solution": "def si_unit_to_base_units(unit_string):\n    \"\"\"\n    Converts an SI unit with a possible prefix to a product of powers of ten and its base units.\n\n    Args:\n        unit_string: The SI unit with a possible prefix (e.g., GW, Mrad, kg).\n\n    Returns:\n        A string representing the unit as a product of a power of ten and its base units\n        (e.g., \"10^9 kg m^2 s^-3\", \"10^6\").\n    \"\"\"\n\n    prefixes = {\n        'Q': 30, 'R': 27, 'Y': 24, 'Z': 21, 'E': 18, 'P': 15,\n        'T': 12, 'G': 9, 'M': 6, 'k': 3, 'h': 2, 'da': 1,\n        'd': -1, 'c': -2, 'm': -3, 'μ': -6, 'n': -9, 'p': -12,\n        'f': -15, 'a': -18, 'z': -21, 'y': -24, 'r': -27, 'q': -30\n    }\n\n    units = {\n        'rad': {'base_units': '1', 'power': 0},\n        'sr': {'base_units': '1', 'power': 0},\n        'Hz': {'base_units': 's^-1', 'power': 0},\n        'N': {'base_units': 'kg m s^-2', 'power': 0},\n        'Pa': {'base_units': 'kg m^-1 s^-2', 'power': 0},\n        'J': {'base_units': 'kg m^2 s^-2', 'power': 0},\n        'W': {'base_units': 'kg m^2 s^-3', 'power': 0},\n        'C': {'base_units': 'A s', 'power': 0},\n        'V': {'base_units': 'kg m^2 s^-3 A^-1', 'power': 0},\n        'F': {'base_units': 'kg^-1 m^-2 s^4 A^2', 'power': 0},\n        'Ω': {'base_units': 'kg m^2 s^-3 A^-2', 'power': 0},\n        'S': {'base_units': 'kg^-1 m^-2 s^3 A^2', 'power': 0},\n        'Wb': {'base_units': 'kg m^2 s^-2 A^-1', 'power': 0},\n        'T': {'base_units': 'kg s^-2 A^-1', 'power': 0},\n        'H': {'base_units': 'kg m^2 s^-2 A^-2', 'power': 0},\n        '°C': {'base_units': 'K', 'power': 0},\n        'lm': {'base_units': 'cd', 'power': 0},\n        'lx': {'base_units': 'cd m^-2', 'power': 0},\n        'Bq': {'base_units': 's^-1', 'power': 0},\n        'Gy': {'base_units': 'm^2 s^-2', 'power': 0},\n        'Sv': {'base_units': 'm^2 s^-2', 'power': 0},\n        'kat': {'base_units': 'mol s^-1', 'power': 0},\n        'kg': {'base_units': 'kg', 'power': 0},\n        'g': {'base_units': 'kg', 'power': -3}  # Special case: gram\n    }\n\n    unit = unit_string\n    power = 0\n\n    # Handle prefixes\n    for prefix, pwr in prefixes.items():\n        if unit.startswith(prefix):\n            unit = unit[len(prefix):]\n            power = pwr\n            break\n\n    # Special handling for kg: it already has a prefix\n    if unit == 'kg':\n        base_units = units['kg']['base_units']\n        unit_power = 0\n\n    #Special handling for g and prefixes for g\n    elif unit == 'g':\n        base_units = units['g']['base_units']\n        unit_power = units['g']['power'] + power\n        power = 0\n\n    elif unit in units:\n        base_units = units[unit]['base_units']\n        unit_power = units[unit]['power']\n    else:\n        return \"Invalid unit\" # Added error handling\n\n    total_power = power + unit_power\n\n    # Format the output\n    if units.get(unit_string.lstrip('QMTRYZEPTGkhdamunpfazyrq'),{}).get('base_units','') == '1': #check unit\n        if total_power == 0:\n            return \"1\"\n        elif total_power == 1:\n            return \"10\"\n        else:\n            return f\"10^{total_power}\"\n    else:\n        if total_power == 0:\n            power_string = \"1\"\n        elif total_power == 1:\n            power_string = \"10\"\n        else:\n            power_string = f\"10^{total_power}\"\n\n        return f\"{power_string} {base_units}\""
  },
  {
    "id": "serpiński-triangle",
    "description": "The Sierpiński triangle is a fractal with the overall shape of an\nequilateral triangle, subdivided recursively into smaller equilateral\ntriangles.\nA Sierpiński triangle of order 4 should look like this, print such an\noutput:\n▲\n▲ ▲\n▲   ▲\n▲ ▲ ▲ ▲\n▲       ▲\n▲ ▲     ▲ ▲\n▲   ▲   ▲   ▲\n▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲\n▲               ▲\n▲ ▲             ▲ ▲\n▲   ▲           ▲   ▲\n▲ ▲ ▲ ▲         ▲ ▲ ▲ ▲\n▲       ▲       ▲       ▲\n▲ ▲     ▲ ▲     ▲ ▲     ▲ ▲\n▲   ▲   ▲   ▲   ▲   ▲   ▲   ▲\n▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲ ▲\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def sierpinski_triangle(n):\n if n==0:return[\"▲\"]\n prev_triangle=sierpinski_triangle(n-1)\n prev_size=len(prev_triangle)\n current_triangle=[]\n for row in prev_triangle:current_triangle.append(\" \"*prev_size+row+\" \"*prev_size)\n for row in prev_triangle:current_triangle.append(row+\" \"+row)\n return current_triangle\ndef main():\n order=4\n triangle_rows=sierpinski_triangle(order)\n for row in triangle_rows:print(row)\nif __name__=='__main__':main()"
  },
  {
    "id": "smith-numbers",
    "description": "A Smith number is a composite number whose digit sum is equal to the sum\nof the digits of its prime factors.\nOne example of a Smith number is the number\n666 = 2 × 3 × 3 × 37, since\n6 + 6 + 6 = 2 + 3 + 3 + (3 + 7) = 18.\nPrint all the Smith numbers from 0 to 10,000 inclusive,\neach on their own line.\nOEIS A006753,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "def sum_digits(n):\n s=0\n while n:s+=n%10;n//=10\n return s\ndef get_prime_factors(n):\n factors=[];d=2;temp=n\n while d*d<=temp:\n  while temp%d==0:factors.append(d);temp//=d\n  d+=1\n if temp>1:factors.append(temp)\n return factors\ndef is_prime(n):\n if n<=1:return False\n if n<=3:return True\n if n%2==0 or n%3==0:return False\n i=5\n while i*i<=n:\n  if n%i==0 or n%(i+2)==0:return False\n  i+=6\n return True\ndef find_smith_numbers(limit):\n smith_numbers=[]\n for num in range(4,limit+1):\n  if not is_prime(num):\n   digit_sum=sum_digits(num)\n   prime_factors=get_prime_factors(num)\n   prime_factors_digit_sum=0\n   for factor in prime_factors:prime_factors_digit_sum+=sum_digits(factor)\n   if digit_sum==prime_factors_digit_sum:smith_numbers.append(num)\n return smith_numbers\nif __name__=='__main__':\n limit=10000\n smith_numbers=find_smith_numbers(limit)\n for num in smith_numbers:print(num)"
  },
  {
    "id": "spelling-numbers",
    "description": "For each integer argument print the integer spelled out in English.\nFor example: 748 becomes seven hundred and forty-eight.\nThe integers will be in the range of 0 (zero) to\n1,000 (one thousand) inclusive.",
    "solution": "import sys\ndef spell_number(n):\n ones=[\"\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\"]\n tens=[\"\",\"\",\"twenty\",\"thirty\",\"forty\",\"fifty\",\"sixty\",\"seventy\",\"eighty\",\"ninety\"]\n if n==0:return\"zero\"\n if n==1000:return\"one thousand\"\n result=[]\n if n>=100:\n  result.append(ones[n//100])\n  result.append(\"hundred\")\n  if n%100!=0:result.append(\"and\")\n  n%=100\n if n>0:\n  if n<20:result.append(ones[n])\n  else:\n   result.append(tens[n//10])\n   if n%10!=0:result.append(ones[n%10])\n output=\" \".join(result).replace(\"ty \",\"ty-\")\n return output\ndef main():\n if len(sys.argv)<2:print(\"Usage: python script.py <integer1> <integer2> ...\");sys.exit(1)\n for arg in sys.argv[1:]:\n  try:\n   num=int(arg)\n   if 0<=num<=1000:print(spell_number(num))\n   else:print(f\"Error: {num} is outside the range of 0 to 1000.\",file=sys.stderr)\n  except ValueError:print(f\"Error: '{arg}' is not a valid integer.\",file=sys.stderr)\nif __name__=='__main__':main()"
  },
  {
    "id": "star-wars-gpt",
    "description": "You are given a series of inputs. Each input contains a text corpus\nand a dozen prompts on subsequent lines. For each prompt, output the\nmost likely next word in the corpus by frequency (aka mode). If\nthere is more than one mode, output the first encountered in the corpus. In\nthis problem, the corpus is fixed to be the\nStar Wars Opening Crawl texts.\nWookieepedia",
    "solution": "import sys\nfrom collections import Counter\ndef predict_word(corpus_text,prompt):\n corpus=corpus_text.split()\n if not prompt or prompt not in corpus:return\"\"\n following_words=[corpus[i+1]for i,word in enumerate(corpus[:-1])if word==prompt]\n if not following_words:return\"\"\n counts=Counter(following_words)\n max_count=max(counts.values())\n modes={word for word,count in counts.items()if count==max_count}\n for word in following_words:\n  if word in modes:return word\ndef main():\n if len(sys.argv)<2:return\n for arg in sys.argv[1:]:\n  lines=arg.strip().split('\\n')\n  if len(lines)>1:\n   corpus=lines[0]\n   prompts=lines[1:]\n   for prompt in prompts:print(predict_word(corpus,prompt))\nif __name__=='__main__':main()"
  },
  {
    "id": "star-wars-opening-crawl",
    "description": "Format a piece of text in the style of Star Wars opening crawl. Here is an\nexample. Input:\n5 21\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\nUt enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nCorresponding output:\nLorem ipsum dolor sit\namet,     consectetur\nadipiscing elit, sed do\neiusmod          tempor\nincididunt  ut  labore et\ndolore magna aliqua.\nUt  enim  ad  minim veniam,\nquis   nostrud   exercitation\nullamco   laboris   nisi   ut\naliquip     ex    ea    commodo\nconsequat.\nHere is how this works. Each test case consists of the following:\nA line containing the initial indentation I and the initial\nline width W, separated by a space.\nSeveral lines of text, each representing a paragraph of the output.\nSplit the text into centred lines that get progressively longer as follows:\nThe first line starts with I spaces and should contain as many words\nas you can fit in W characters (so lines may only be wrapped where\nthere are spaces in the input).\nIf the resulting line contains fewer than W characters, pad out the\nline by adding spaces between the words as evenly as possible to get to\nW characters in total. If some gaps require extra spaces, add them\nstarting from the left. Example:\nMay the Force be with you!\nThis line contains 26 characters and has 5 gaps. If we had W = 33,\nthe result should look like:\nMay   the   Force  be  with  you!\nAfter every pair of lines, reduce I by 1 and increase W by 2.\nContinue this way through all of the input. The last line of each paragraph\nshould not be justified (i.e. don't add any spaces to it). And\nparagraphs should be separated by an empty line that does count towards the\nprogression of I and W.\nThis hole contains multiple test cases (one argument per test case). Separate\nthe output for multiple test cases by an empty line.\nWookieepedia",
    "solution": "import sys\ndef justify_line(words,width):\n num_words=len(words)\n if num_words<=1:return\" \".join(words)\n total_word_length=sum(len(w)for w in words)\n total_spaces=width-total_word_length\n num_gaps=num_words-1\n if num_gaps<=0:return\"\".join(words)\n base_spaces=total_spaces//num_gaps\n extra_spaces=total_spaces%num_gaps\n parts=[]\n for i,word in enumerate(words):\n  parts.append(word)\n  if i<num_gaps:parts.append(\" \"*(base_spaces+(1 if i<extra_spaces else 0)))\n return\"\".join(parts)\ndef format_crawl(input_text):\n lines=input_text.strip().split('\\n')\n if not lines:return\n try:initial_I,initial_W=map(int,lines[0].split())\n except(ValueError,IndexError):return\n current_I=initial_I\n current_W=initial_W\n line_counter=0\n formatted_output=[]\n paragraphs=lines[1:]\n for paragraph in paragraphs:\n  all_words=paragraph.split()\n  word_idx=0\n  while word_idx<len(all_words):\n   current_line_words=[]\n   current_line_length=0\n   start_word_idx=word_idx\n   while word_idx<len(all_words):\n    word=all_words[word_idx]\n    word_len=len(word)\n    if not current_line_words:\n     current_line_words.append(word)\n     current_line_length=word_len\n    elif current_line_length+1+word_len<=current_W:\n     current_line_words.append(word)\n     current_line_length+=1+word_len\n    else:break\n    word_idx+=1\n   is_last_line_of_paragraph=(word_idx==len(all_words))\n   prefix=\" \"*current_I\n   if is_last_line_of_paragraph:formatted_line=\" \".join(current_line_words)\n   else:formatted_line=justify_line(current_line_words,current_W)\n   formatted_output.append(prefix+formatted_line)\n   line_counter+=1\n   if line_counter%2==0:\n    current_I-=1\n    current_W+=2\n  if paragraph!=paragraphs[-1]:\n   formatted_output.append(\"\")\n   line_counter+=1\n   if line_counter%2==0:\n    current_I-=1\n    current_W+=2\n return\"\\n\".join(formatted_output)\ndef main():\n if len(sys.argv)<2:\n  print(\"Usage: python script.py \\\"<test_case_1>\\\" \\\"<test_case_2>\\\" ...\",file=sys.stderr)\n  sys.exit(1)\n all_outputs=[]\n for arg in sys.argv[1:]:\n  formatted_text=format_crawl(arg)\n  if formatted_text:all_outputs.append(formatted_text)\n print(\"\\n\\n\".join(all_outputs))\nif __name__=='__main__':main()"
  },
  {
    "id": "sudoku",
    "description": "Sudoku is a number puzzle where a grid of 81 digits (9×9) is filled by the\ndigits 1-9 such that no row, column, or 3×3 subregion contains duplicate\ndigits.\nWrite a program that given an incomplete Sudoku board as 9 arguments of 9\ndigits, with blanks represented by an underscore, prints a solved Sudoku\ngrid using Unicode box-drawing characters like so:\n┏━━━┯━━━┯━━━┳━━━┯━━━┯━━━┳━━━┯━━━┯━━━┓\n┃ 2 │ 5 │ 8 ┃ 4 │ 1 │ 7 ┃ 6 │ 9 │ 3 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 6 │ 1 │ 7 ┃ 9 │ 2 │ 3 ┃ 8 │ 5 │ 4 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 9 │ 3 │ 4 ┃ 8 │ 6 │ 5 ┃ 1 │ 7 │ 2 ┃\n┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\n┃ 3 │ 2 │ 5 ┃ 7 │ 8 │ 1 ┃ 4 │ 6 │ 9 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 8 │ 9 │ 6 ┃ 3 │ 5 │ 4 ┃ 2 │ 1 │ 7 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 7 │ 4 │ 1 ┃ 6 │ 9 │ 2 ┃ 5 │ 3 │ 8 ┃\n┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\n┃ 4 │ 6 │ 9 ┃ 1 │ 3 │ 8 ┃ 7 │ 2 │ 5 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 5 │ 7 │ 3 ┃ 2 │ 4 │ 6 ┃ 9 │ 8 │ 1 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 1 │ 8 │ 2 ┃ 5 │ 7 │ 9 ┃ 3 │ 4 │ 6 ┃\n┗━━━┷━━━┷━━━┻━━━┷━━━┷━━━┻━━━┷━━━┷━━━┛\nVariants:\nSudoku (Fill-in)\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef solve_sudoku(board):\n empty_cell=find_empty_cell(board)\n if not empty_cell:return True\n row,col=empty_cell\n for num in range(1,10):\n  if is_valid(board,row,col,str(num)):\n   board[row][col]=str(num)\n   if solve_sudoku(board):return True\n   board[row][col]='.'\n return False\ndef find_empty_cell(board):\n for row in range(9):\n  for col in range(9):\n   if board[row][col]=='.':return(row,col)\n return None\ndef is_valid(board,row,col,num):\n for i in range(9):\n  if board[row][i]==num:return False\n for i in range(9):\n  if board[i][col]==num:return False\n start_row=(row//3)*3\n start_col=(col//3)*3\n for i in range(3):\n  for j in range(3):\n   if board[start_row+i][start_col+j]==num:return False\n return True\ndef print_formatted_board(board):\n top_border=\"┏━━━┯━━━┯━━━┳━━━┯━━━┯━━━┳━━━┯━━━┯━━━┓\"\n middle_border=\"┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\"\n heavy_border=\"┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\"\n bottom_border=\"┗━━━┷━━━┷━━━┻━━━┷━━━┷━━━┻━━━┷━━━┷━━━┛\"\n print(top_border)\n for i in range(9):\n  row_str=\"┃\"\n  for j in range(9):\n   row_str+=f\" {board[i][j]} \"\n   if(j+1)%3==0:row_str+=\"┃\"\n   else:row_str+=\"│\"\n  print(row_str)\n  if i==8:print(bottom_border)\n  elif(i+1)%3==0:print(heavy_border)\n  else:print(middle_border)\ndef main():\n if len(sys.argv)!=10:\n  print(\"Usage: python script.py <row1> <row2> ... <row9>\",file=sys.stderr)\n  sys.exit(1)\n board=[]\n for i in range(1,10):\n  row_str=sys.argv[i]\n  if len(row_str)!=9:\n   print(f\"Error: Row {i} must have 9 characters.\",file=sys.stderr)\n   sys.exit(1)\n  board.append(list(row_str.replace('_','.')))\n if solve_sudoku(board):print_formatted_board(board)\n else:print(\"该数独无解。\")\nif __name__=='__main__':main()"
  },
  {
    "id": "sudoku-fill-in",
    "description": "Sudoku is a number puzzle where a grid of 81 digits (9×9) is filled by the\ndigits 1-9 such that no row, column, or 3×3 subregion contains duplicate\ndigits.\nWrite a program that given an incomplete Sudoku board as an argument,\nprints the solved Sudoku board. The grid will be drawn with Unicode\nbox-drawing characters like so:\n┏━━━┯━━━┯━━━┳━━━┯━━━┯━━━┳━━━┯━━━┯━━━┓\n┃ 2 │ 5 │ 8 ┃ 4 │ 1 │ 7 ┃ 6 │ 9 │ 3 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 6 │ 1 │ 7 ┃ 9 │ 2 │ 3 ┃ 8 │ 5 │ 4 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 9 │ 3 │ 4 ┃ 8 │ 6 │ 5 ┃ 1 │ 7 │ 2 ┃\n┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\n┃ 3 │ 2 │ 5 ┃ 7 │ 8 │ 1 ┃ 4 │ 6 │ 9 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 8 │ 9 │ 6 ┃ 3 │ 5 │ 4 ┃ 2 │ 1 │ 7 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 7 │ 4 │ 1 ┃ 6 │ 9 │ 2 ┃ 5 │ 3 │ 8 ┃\n┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\n┃ 4 │ 6 │ 9 ┃ 1 │ 3 │ 8 ┃ 7 │ 2 │ 5 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 5 │ 7 │ 3 ┃ 2 │ 4 │ 6 ┃ 9 │ 8 │ 1 ┃\n┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\n┃ 1 │ 8 │ 2 ┃ 5 │ 7 │ 9 ┃ 3 │ 4 │ 6 ┃\n┗━━━┷━━━┷━━━┻━━━┷━━━┷━━━┻━━━┷━━━┷━━━┛\nVariants:\nSudoku\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef parse_formatted_board(input_string):\n lines=input_string.strip().split('\\n')\n board=[]\n for line in lines:\n  if\"┃\"in line:\n   row=[line[2+i*4]if not line[2+i*4].isspace()else'.'for i in range(9)]\n   board.append(row)\n if len(board)!=9 or any(len(r)!=9 for r in board):raise ValueError(\"输入格式不正确，无法解析为9x9数独棋盘。\")\n return board\ndef solve_sudoku(board):\n empty_cell=find_empty_cell(board)\n if not empty_cell:return True\n row,col=empty_cell\n for num in range(1,10):\n  num_str=str(num)\n  if is_valid(board,row,col,num_str):\n   board[row][col]=num_str\n   if solve_sudoku(board):return True\n   board[row][col]='.'\n return False\ndef find_empty_cell(board):\n for r,row in enumerate(board):\n  for c,cell in enumerate(row):\n   if cell=='.':return r,c\n return None\ndef is_valid(board,row,col,num_str):\n if num_str in board[row]or num_str in[board[i][col]for i in range(9)]:return False\n start_row,start_col=(row//3)*3,(col//3)*3\n for i in range(3):\n  for j in range(3):\n   if board[start_row+i][start_col+j]==num_str:return False\n return True\ndef print_formatted_board(board):\n top_border=\"┏━━━┯━━━┯━━━┳━━━┯━━━┯━━━┳━━━┯━━━┯━━━┓\"\n middle_border=\"┠───┼───┼───╂───┼───┼───╂───┼───┼───┨\"\n heavy_border=\"┣━━━┿━━━┿━━━╋━━━┿━━━┿━━━╋━━━┿━━━┿━━━┫\"\n bottom_border=\"┗━━━┷━━━┷━━━┻━━━┷━━━┷━━━┻━━━┷━━━┷━━━┛\"\n print(top_border)\n for i,row in enumerate(board):\n  row_str=\"┃\"+\"\".join(f\" {cell} \"+(\"┃\"if(j+1)%3==0 else\"│\")for j,cell in enumerate(row))\n  print(row_str)\n  if i==8:print(bottom_border)\n  elif(i+1)%3==0:print(heavy_border)\n  else:print(middle_border)\ndef main():\n if len(sys.argv)<2:\n  print(\"Usage: python script.py \\\"<formatted_sudoku_board>\\\"\",file=sys.stderr)\n  sys.exit(1)\n try:\n  board=parse_formatted_board(sys.argv[1])\n  if solve_sudoku(board):print_formatted_board(board)\n  else:print(\"The puzzle has no solution.\")\n except ValueError as e:print(e,file=sys.stderr)\nif __name__=='__main__':main()"
  },
  {
    "id": "ten-pin-bowling",
    "description": "Given a series of ten-pin bowling scoreboards, determine the final scores\nbased on the\ntraditional scoring method.\nA game consists of ten frames. Each frame, players get up to two rolls to\nknock down all ten pins.\nIf a player gets a strike in the final frame, they get two extra rolls. If\nthey get a strike in one of the first nine frames, the value of the\nfollowing two rolls, which may cover multiple frames, is added as a bonus.\nIf a player gets a spare in the final frame, they get one extra roll. If\nthey get a spare in one of the first nine frames, the value of the\nfollowing roll is added as a bonus.\nEach argument represents one game of\nbowling for one player. For each roll, a single character represents the\nnumber of pins knocked down. Frames are separated by spaces. The following\nsymbols are used.\nSymbol\nDescription\nX\nStrike - all ten pins were knocked down on the first roll\nof a frame, or the bonus rolls of the final frame. A\nstrike in the first nine frames is represented by a space\nfollowed by an X, as if the strike happened on the frame’s\nsecond roll, even though the frame consists of a single\nroll.\n/\nSpare - all remaining pins were knocked down on the second\nroll of a frame, or the second bonus roll of the final\nframe.\nF\nFoul - part of the bowler’s body went past the foul line.\n-\nMiss - No pins were knocked down.\n⑤⑥⑦⑧\nSplit - the foremost pin is knocked down and there is a\ngap of at least one pin between the pins that remain\nstanding.\nOutput the total score for each game on a separate line. The total score\nis the total number of pins knocked down plus strike and spare bonuses.\nWikipedia",
    "solution": "import sys\ndef calculate_score(game_string):\n game_string=game_string.replace('⑧','8').replace('⑦','7').replace('⑥','6').replace('⑤','5')\n char_to_score={'X':10,'/':-1,'F':0,'-':0}\n rolls=[]\n for char in game_string:\n  if char==' ':continue\n  elif char in char_to_score:rolls.append(char_to_score[char])\n  elif char.isdigit():rolls.append(int(char))\n for i,score in enumerate(rolls):\n  if score==-1:rolls[i]=10-rolls[i-1]\n total_score,roll_index=0,0\n for frame in range(10):\n  if frame<9:\n   if rolls[roll_index]==10:\n    total_score+=10+rolls[roll_index+1]+rolls[roll_index+2]\n    roll_index+=1\n   elif rolls[roll_index]+rolls[roll_index+1]==10:\n    total_score+=10+rolls[roll_index+2]\n    roll_index+=2\n   else:\n    total_score+=rolls[roll_index]+rolls[roll_index+1]\n    roll_index+=2\n  else:total_score+=sum(rolls[roll_index:])\n return total_score\ndef main():\n if len(sys.argv)<2:return\n game_strings=sys.argv[1:]\n for game_string in game_strings:print(calculate_score(game_string))\nif __name__=='__main__':main()"
  },
  {
    "id": "tic-tac-toe",
    "description": "Given a finished grid state in tic-tac-toe, determine which character wins\nthe game.\nPrint X or O when three consecutive characters complete a\nhorizontal, vertical, or diagonal line; or - when no such line is\ncompleted.\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef check_winner(board_string):\n board=[list(row)for row in board_string.split('\\n')]\n for i in range(3):\n  if board[i][0]==board[i][1]==board[i][2]!='.':return board[i][0]\n  if board[0][i]==board[1][i]==board[2][i]!='.':return board[0][i]\n if board[0][0]==board[1][1]==board[2][2]!='.':return board[0][0]\n if board[0][2]==board[1][1]==board[2][0]!='.':return board[0][2]\n return'-'\ndef main():\n if len(sys.argv)<2:return\n for board_arg in sys.argv[1:]:print(check_winner(board_arg))\nif __name__=='__main__':main()"
  },
  {
    "id": "time-distance",
    "description": "Transform a time distance given as a number of seconds to a human-friendly\nstring representation.\nZero represents the current moment,\nto be printed as now.\nPositive values represent the\nfuture, to be printed with the in prefix.\nNegative values represent the past,\nto be printed with the ago suffix.\nThe largest possible unit of time among a second, a minute (60 seconds),\nan hour (60 minutes), a day (24 hours), a week (7 days), a month (30 days)\nand a year (365 days) is always chosen and the quantity is always rounded\ntowards zero.\nThe correct singular/plural of each unit must be used. If the quantity is\n1, print a month and an hour rather than\n1 month and 1 hour.",
    "solution": "import sys\ndef format_time_distance(seconds):\n if seconds==0:return\"now\"\n is_future=seconds>0\n abs_seconds=abs(seconds)\n units=[('year',31536000),('month',2592000),('week',604800),('day',86400),('hour',3600),('minute',60),('second',1)]\n unit_name=''\n quantity=0\n for name,unit_seconds in units:\n  if abs_seconds>=unit_seconds:\n   quantity=abs_seconds//unit_seconds\n   unit_name=name\n   break\n else:\n  quantity=abs_seconds\n  unit_name='second'\n if quantity==1:\n  prefix=\"an\"if unit_name==\"hour\"else\"a\"\n  formatted_string=f\"{prefix} {unit_name}\"\n else:formatted_string=f\"{quantity} {unit_name}s\"\n return f\"in {formatted_string}\"if is_future else f\"{formatted_string} ago\"\ndef main():\n if len(sys.argv)<2:return\n for time_str in sys.argv[1:]:\n  time_int=int(time_str)\n  print(format_time_distance(time_int))\nif __name__=='__main__':main()"
  },
  {
    "id": "tongue-twisters",
    "description": "Print the following tongue twisters with a blank line between each one:\nHow much wood would a woodchuck chuck,\nIf a woodchuck could chuck wood?\nA woodchuck would chuck all the wood he could chuck\nIf a woodchuck would chuck wood.\nPeter Piper picked a peck of pickled peppers.\nA peck of pickled peppers Peter Piper picked.\nIf Peter Piper picked a peck of pickled peppers,\nWhere's the peck of pickled peppers Peter Piper picked?\nShe sells seashells by the seashore,\nThe shells she sells are seashells, I'm sure.\nSo if she sells seashells on the seashore,\nThen I'm sure she sells seashore shells.\nWikipedia\nCopy Answer\nCopied",
    "solution": "def print_tongue_twisters():\n    tongue_twisters = [\n        \"\"\"How much wood would a woodchuck chuck,\nIf a woodchuck could chuck wood?\nA woodchuck would chuck all the wood he could chuck\nIf a woodchuck would chuck wood.\"\"\",\n        \"\"\"Peter Piper picked a peck of pickled peppers.\nA peck of pickled peppers Peter Piper picked.\nIf Peter Piper picked a peck of pickled peppers,\nWhere's the peck of pickled peppers Peter Piper picked?\"\"\",\n        \"\"\"She sells seashells by the seashore,\nThe shells she sells are seashells, I'm sure.\nSo if she sells seashells on the seashore,\nThen I'm sure she sells seashore shells.\"\"\"\n    ]\n\n    for i, twister in enumerate(tongue_twisters):\n        print(twister)\n        if i < len(tongue_twisters) - 1:\n            print()\n\nif __name__ == \"__main__\":\n    print_tongue_twisters()"
  },
  {
    "id": "topological-sort",
    "description": "Given the set of edges of a directed graph, print the linear order of its nodes. The order is always unique. Each edge is given on a separate line; an edge from node u to node v is given as u v. The nodes are numbered from 0 to N - 1, where 2 ≤ N ≤ 10 is the number of nodes in the graph.\nThis is similar to the tsort utility, except that output nodes are separated with spaces instead of newlines.",
    "solution": "import sys\ndef topological_sort(edges_string):\n edges=[list(map(int,line.split()))for line in edges_string.strip().split('\\n')if line.strip()]\n if not edges:return\"\"\n nodes={n for edge in edges for n in edge}\n num_nodes=max(nodes)+1 if nodes else 0\n adj={i:[]for i in range(num_nodes)}\n in_degree=[0]*num_nodes\n for u,v in edges:\n  adj[u].append(v)\n  in_degree[v]+=1\n queue=[i for i in range(num_nodes)if in_degree[i]==0]\n result=[]\n head=0\n while head<len(queue):\n  u=queue[head]\n  head+=1\n  result.append(str(u))\n  for v in adj[u]:\n   in_degree[v]-=1\n   if in_degree[v]==0:queue.append(v)\n return\" \".join(result)if len(result)==num_nodes else\"Error: A topological sort is not possible.\"\ndef main():\n if len(sys.argv)<2:return\n for arg in sys.argv[1:]:print(topological_sort(arg))\nif __name__=='__main__':main()"
  },
  {
    "id": "transpose-sentence",
    "description": "Given a list of sentences, print the transposed representation of each\ninput.\nConsider the sentence: all work and no play makes jack a dull boy.\nTo transpose it, first write each word on a separate line:\n₁₂₃₄₅\n↓↓↓↓↓\nall\nwork\nand\nno\nplay\nmakes\njack\na\ndull\nboy\nThen read the block of text top to bottom, left to right, inserting a\nspace after the last letter of each column, which yields:\nawanpmjadb lonolaauo lrdakcly kyekl s.",
    "solution": "import sys\ndef transpose_sentence(sentence):\n words=sentence.split()\n if not words:return\"\"\n max_len=max(len(word)for word in words)\n transposed_columns=[]\n for i in range(max_len):\n  column_str=\"\"\n  for word in words:\n   if i<len(word):column_str+=word[i]\n  transposed_columns.append(column_str)\n return\" \".join(transposed_columns)\ndef main():\n for sentence in sys.argv[1:]:print(transpose_sentence(sentence))\nif __name__=='__main__':main()"
  },
  {
    "id": "united-states",
    "description": "Given each US state (and a federal district) print the corresponding US\nPostal Service abbreviation.\nThe full mapping is as follows:\nStateAbbr.\nAlabamaAL\nAlaskaAK\nArizonaAZ\nArkansasAR\nCaliforniaCA\nColoradoCO\nConnecticutCT\nDelawareDE\nDistrict of ColumbiaDC\nFloridaFL\nGeorgiaGA\nHawaiiHI\nIdahoID\nStateAbbr.\nIllinoisIL\nIndianaIN\nIowaIA\nKansasKS\nKentuckyKY\nLouisianaLA\nMaineME\nMarylandMD\nMassachusettsMA\nMichiganMI\nMinnesotaMN\nMississippiMS\nMissouriMO\nStateAbbr.\nMontanaMT\nNebraskaNE\nNevadaNV\nNew HampshireNH\nNew JerseyNJ\nNew MexicoNM\nNew YorkNY\nNorth CarolinaNC\nNorth DakotaND\nOhioOH\nOklahomaOK\nOregonOR\nPennsylvaniaPA\nStateAbbr.\nRhode IslandRI\nSouth CarolinaSC\nSouth DakotaSD\nTennesseeTN\nTexasTX\nUtahUT\nVermontVT\nVirginiaVA\nWashingtonWA\nWest VirginiaWV\nWisconsinWI\nWyomingWY\nCopy as JSON\nCopied",
    "solution": "import sys\ndef main():\n state_abbreviations={\"alabama\":\"AL\",\"alaska\":\"AK\",\"arizona\":\"AZ\",\"arkansas\":\"AR\",\"california\":\"CA\",\"colorado\":\"CO\",\"connecticut\":\"CT\",\"delaware\":\"DE\",\"district of columbia\":\"DC\",\"florida\":\"FL\",\"georgia\":\"GA\",\"hawaii\":\"HI\",\"idaho\":\"ID\",\"illinois\":\"IL\",\"indiana\":\"IN\",\"iowa\":\"IA\",\"kansas\":\"KS\",\"kentucky\":\"KY\",\"louisiana\":\"LA\",\"maine\":\"ME\",\"maryland\":\"MD\",\"massachusetts\":\"MA\",\"michigan\":\"MI\",\"minnesota\":\"MN\",\"mississippi\":\"MS\",\"missouri\":\"MO\",\"montana\":\"MT\",\"nebraska\":\"NE\",\"nevada\":\"NV\",\"new hampshire\":\"NH\",\"new jersey\":\"NJ\",\"new mexico\":\"NM\",\"new york\":\"NY\",\"north carolina\":\"NC\",\"north dakota\":\"ND\",\"ohio\":\"OH\",\"oklahoma\":\"OK\",\"oregon\":\"OR\",\"pennsylvania\":\"PA\",\"rhode island\":\"RI\",\"south carolina\":\"SC\",\"south dakota\":\"SD\",\"tennessee\":\"TN\",\"texas\":\"TX\",\"utah\":\"UT\",\"vermont\":\"VT\",\"virginia\":\"VA\",\"washington\":\"WA\",\"west virginia\":\"WV\",\"wisconsin\":\"WI\",\"wyoming\":\"WY\"}\n if len(sys.argv)<2:\n  print(\"Usage: python test.py \\\"State 1\\\" \\\"State 2\\\" ...\",file=sys.stderr)\n  sys.exit(1)\n for state_name in sys.argv[1:]:\n  lower_name=state_name.lower()\n  if lower_name in state_abbreviations:print(state_abbreviations[lower_name])\nif __name__=='__main__':main()"
  },
  {
    "id": "vampire-numbers",
    "description": "A vampire number is a non-negative number that can be factored into two\nnumbers (fangs) each with half as many digits as the original where the\ntwo factors contain all the digits of the original, in any order. One but\nnot both fangs may have trailing zeros.\nFor example 1260 = 21×60, 1395 = 15×93, 1435 = 35×41,\n1530 = 30×51, etc.\nPrint all the vampire numbers from 1 to 1,000,000 inclusive,\neach on their own line.\nBe careful with the algorithmic complexity of your solution to avoid\ntiming out.\nOEIS A014575,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import sys\ndef find_vampire_numbers(num_digits):\n vampire_numbers=set()\n fang_digits=num_digits//2\n start_fang=10**(fang_digits-1)\n end_fang=10**fang_digits-1\n for a in range(start_fang,end_fang+1):\n  for b in range(a,end_fang+1):\n   if a%10==0 and b%10==0:continue\n   product=a*b\n   if len(str(product))!=num_digits:continue\n   product_digits=sorted(str(product))\n   fangs_digits=sorted(str(a)+str(b))\n   if product_digits==fangs_digits:vampire_numbers.add(product)\n return vampire_numbers\ndef main():\n all_vampire_numbers=set()\n all_vampire_numbers.update(find_vampire_numbers(4))\n all_vampire_numbers.update(find_vampire_numbers(6))\n for number in sorted(all_vampire_numbers):print(number)\nif __name__=='__main__':main()"
  },
  {
    "id": "van-eck-sequence",
    "description": "The rules of the Van Eck sequence are as follows:\nThe first term is zero.\nIf the last term is new then the next term is zero.\nOtherwise the next term is how far back the term occurred previously.\nThe first few terms are as follows:\n0         (using a)\n0 0       (using b)\n0 0 1     (using c)\n0 0 1 0   (using b)\n0 0 1 0 2 (using c)\nPrint the first 1,000 terms of the Van Eck sequence, with each term\non a new line.\nNumberphile,\nOEIS A181391,\nRosetta Code\nCopy Answer\nCopied",
    "solution": "def van_eck_sequence(n):\n    \"\"\"\n    Generates the first n terms of the Van Eck sequence.\n\n    Args:\n      n: The number of terms to generate.\n\n    Returns:\n      A list containing the first n terms of the Van Eck sequence.\n    \"\"\"\n\n    sequence = [0]\n    seen = {0: 0}  # Store the last seen index of each number\n\n    for i in range(1, n):\n        last_term = sequence[-1]\n        if last_term not in seen:\n            next_term = 0\n            sequence.append(next_term)\n            seen[last_term] = i - 1 # store the index BEFORE adding current element, as this is last index for that term\n            if next_term not in seen:\n                seen[next_term] = i\n        else:\n            last_seen = seen[last_term]\n            next_term = (i - 1) - last_seen  # Calculate the distance\n            sequence.append(next_term)\n            seen[last_term] = i - 1  # Update last seen index\n            if next_term not in seen:\n                seen[next_term] = i\n\n    return sequence\n\n\nif __name__ == \"__main__\":\n    terms = van_eck_sequence(1000)\n    for term in terms:\n        print(term)"
  },
  {
    "id": "zeckendorf-representation",
    "description": "Every natural number can be written uniquely as the sum of Fibonacci\nnumbers in a way that avoids using consecutive Fibonacci numbers.\nFor example, 10 = 8 + 2, and 64 = 55 + 8 + 1.\nThis sum is called the Zeckendorf representation.\nPrint the Zeckendorf representation for each input argument.\nTerms should be listed in decreasing order separated by ' + '.\nFor example, input 10 should produce 8 + 2.\nInputs are in the range 1 (inclusive) to 231 (exclusive).\nRosetta Code,\nWikipedia",
    "solution": "import sys\ndef get_fibonacci_sequence(limit):\n fibs=[1,2]\n a,b=1,2\n while b<=limit:a,b=b,a+b;fibs.append(b)\n return fibs\ndef find_zeckendorf_representation(n,fibs):\n representation=[]\n for fib in reversed(fibs):\n  if n>=fib:representation.append(str(fib));n-=fib\n return\" + \".join(representation)\ndef main():\n fib_limit=2**31\n fibonacci_numbers=get_fibonacci_sequence(fib_limit)\n if len(sys.argv)<2:\n  print(\"Usage: python script.py <number1> <number2> ...\",file=sys.stderr)\n  sys.exit(1)\n for arg in sys.argv[1:]:\n  try:\n   num=int(arg)\n   if num<1 or num>=fib_limit:\n    print(f\"Input {num} is out of the valid range (1 to 2^31-1).\",file=sys.stderr)\n    continue\n   representation=find_zeckendorf_representation(num,fibonacci_numbers)\n   print(representation)\n  except ValueError:print(f\"Invalid input: '{arg}' is not a valid integer.\",file=sys.stderr)\nif __name__=='__main__':main()"
  },
  {
    "id": "zodiac-signs",
    "description": "Given a MM-DD HH:MM date and time, output the corresponding\nZodiac sign symbol according to the first table below. If the ascending\nsign is different from the Zodiac sign (sun sign), output it as well.\nApproximate the ascending sign using the sun sign and time according to\nthe second table below.\nSignSymbolDate\nAries♈March 21 – April 19\nTaurus♉April 20 – May 20\nGemini♊May 21 – June 21\nCancer♋June 22 – July 22\nLeo♌July 23 – August 22\nVirgo♍August 23 – September 22\nLibra♎September 23 – October 22\nScorpio♏October 23 – November 22\nSagittarius♐November 23 – December 21\nCapricorn♑December 22 – January 19\nAquarius♒January 20 – February 18\nPisces♓February 19 – March 20\nTime/Sun Symbol\n♈♉♊♋♌♍♎♏♐♑♒♓\n00:00 - 01:59\n♒♓♈♉♊♋♌♍♎♏♐♑\n02:00 - 03:59\n♓♈♉♊♋♌♍♎♏♐♑♒\n04:00 - 05:59\n♈♉♊♋♌♍♎♏♐♑♒♓\n06:00 - 07:59\n♉♊♋♌♍♎♏♐♑♒♓♈\n08:00 - 09:59\n♊♋♌♍♎♏♐♑♒♓♈♉\n10:00 - 11:59\n♋♌♍♎♏♐♑♒♓♈♉♊\n12:00 - 13:59\n♌♍♎♏♐♑♒♓♈♉♊♋\n14:00 - 15:59\n♍♎♏♐♑♒♓♈♉♊♋♌\n16:00 - 17:59\n♎♏♐♑♒♓♈♉♊♋♌♍\n18:00 - 19:59\n♏♐♑♒♓♈♉♊♋♌♍♎\n20:00 - 21:59\n♐♑♒♓♈♉♊♋♌♍♎♏\n22:00 - 23:59\n♑♒♓♈♉♊♋♌♍♎♏♐\nZodiac Sign Wikipedia,\nAscending Sign Wikipedia",
    "solution": "import sys\nSUN_SIGNS=[('Capricorn','♑',(12,22),(12,31)),('Aquarius','♒',(1,20),(2,18)),('Pisces','♓',(2,19),(3,20)),('Aries','♈',(3,21),(4,19)),('Taurus','♉',(4,20),(5,20)),('Gemini','♊',(5,21),(6,21)),('Cancer','♋',(6,22),(7,22)),('Leo','♌',(7,23),(8,22)),('Virgo','♍',(8,23),(9,22)),('Libra','♎',(9,23),(10,22)),('Scorpio','♏',(10,23),(11,22)),('Sagittarius','♐',(11,23),(12,21)),('Capricorn','♑',(1,1),(1,19))]\nSUN_ORDER=['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓']\nASC_ROWS=[list('♒♓♈♉♊♋♌♍♎♏♐♑'),list('♓♈♉♊♋♌♍♎♏♐♑♒'),list('♈♉♊♋♌♍♎♏♐♑♒♓'),list('♉♊♋♌♍♎♏♐♑♒♓♈'),list('♊♋♌♍♎♏♐♑♒♓♈♉'),list('♋♌♍♎♏♐♑♒♓♈♉♊'),list('♌♍♎♏♐♑♒♓♈♉♊♋'),list('♍♎♏♐♑♒♓♈♉♊♋♌'),list('♎♏♐♑♒♓♈♉♊♋♌♍'),list('♏♐♑♒♓♈♉♊♋♌♍♎'),list('♐♑♒♓♈♉♊♋♌♍♎♏'),list('♑♒♓♈♉♊♋♌♍♎♏♐')]\ndef sun_sign(month,day):\n for name,sym,(m1,d1),(m2,d2)in SUN_SIGNS:\n  if(month,day)>=(m1,d1)and(month,day)<=(m2,d2):return sym\n return''\ndef ascendant(sun_sym,hour):\n slot=hour//2\n row=ASC_ROWS[slot]\n idx=SUN_ORDER.index(sun_sym)\n return row[idx]\ndef main():\n for arg in sys.argv[1:]:\n  date,time=arg.split()\n  mm,dd=map(int,date.split('-'))\n  hh,_=map(int,time.split(':'))\n  sun=sun_sign(mm,dd)\n  asc=ascendant(sun,hh)\n  if asc!=sun:print(f\"{sun}{asc}\")\n  else:print(sun)\nif __name__=='__main__':main()"
  },
  {
    "id": "γ",
    "description": "Print the first 1,000 decimal digits of the Euler–Mascheroni constant γ (gamma).\nOEIS A001620,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal as D\ndecimal.getcontext().prec=1200\ndef bernoulli_numbers(m):\n A=[D(0)]*(2*m+1)\n B=[]\n for n in range(2*m+1):\n  A[n]=D(1)/(n+1)\n  for k in range(n,0,-1):A[k-1]=k*(A[k-1]-A[k])\n  if n%2==0:B.append(A[0])\n return B\ndef compute_gamma():\n N=20000\n m=200\n H=sum(D(1)/D(k)for k in range(1,N+1))\n lnN=D(N).ln()\n B=bernoulli_numbers(m)\n corr=-D(1)/(2*D(N))\n for k in range(1,m+1):corr+=B[k]/(D(2*k)*(D(N)**(2*k)))\n return H-lnN+corr\nγ=compute_gamma()\ns=format(γ,'f')\nintp,fracp=s.split('.')\nfracp=(fracp+'0'*1000)[:1000]\nprint(f\"{intp}.{fracp}\")"
  },
  {
    "id": "λ",
    "description": "Conway’s constant λ is a mathematical constant related to the growth of\nthe look-and-say sequence.\nIt is the unique positive root of\nthis large polynomial.\nPrint the first 1,000 decimal digits of λ.\nOEIS A014715,\nWikipedia\nCopy Answer\nCopied",
    "solution": "POLY_COEFFS=[-6,3,-6,12,-4,7,-7,1,0,5,-2,-4,-12,2,7,12,-7,-10,-4,3,9,-7,0,-8,14,-3,9,2,-3,-10,-2,-6,1,10,-3,1,7,-7,7,-12,-5,8,6,10,-8,-8,-7,-3,9,1,6,6,-2,-3,-10,-2,3,5,2,-1,-1,-1,-1,-1,1,2,2,-1,-2,-1,0,1]\ndef eval_poly(x,coeffs,scale,deriv=False):\n n=len(coeffs)\n result=0\n if deriv:\n  for i in range(n-1,0,-1):\n   c=coeffs[i]*i\n   result=(x*result)//scale+c*scale\n else:\n  for i in range(n-1,-1,-1):\n   c=coeffs[i]\n   result=(x*result)//scale+c*scale\n return result\ndef compute_conway_constant():\n scale=10**2000\n x=4*scale//3\n for _ in range(20):\n  f_val=eval_poly(x,POLY_COEFFS,scale,deriv=False)\n  df_val=eval_poly(x,POLY_COEFFS,scale,deriv=True)\n  if df_val==0:break\n  x-=(f_val*scale)//df_val\n s=str(x)\n if len(s)<1001:s=s+\"0\"*(1001-len(s))\n return s[0]+\".\"+s[1:1001]\nif __name__=='__main__':print(compute_conway_constant())"
  },
  {
    "id": "π",
    "description": "Print the first 1,000 decimal digits of π (pi).\nVariants:\nτ\nOEIS A000796,\nRosetta Code,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal as D,getcontext\ndef compute_pi(digits):\n getcontext().prec=digits+20\n C=426880*D(10005).sqrt()\n M,L,X,K,S=D(1),D(13591409),D(1),D(6),D(13591409)\n for k in range(1,digits//14+10):\n  M=(M*(K**3-16*K))/(k**3)\n  L+=545140134\n  X*=-262537412640768000\n  term=M*L/X\n  S+=term\n  if abs(term)<D(1)/(D(10)**(digits+5)):break\n  K+=12\n return +C/S\ndef main():\n digits=1000\n pi=compute_pi(digits)\n s=format(pi,'f')\n intp,fracp=s.split('.')\n fracp=(fracp+'0'*digits)[:digits]\n print(f\"{intp}.{fracp}\")\nif __name__=='__main__':main()"
  },
  {
    "id": "τ",
    "description": "Print the first 1,000 decimal digits of 2π=τ (tau).\nVariants:\nπ\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal as D,getcontext\ndef compute_pi(digits):\n getcontext().prec=digits+20\n C=D(426880)*D(10005).sqrt()\n M,L,X,K,S=D(1),D(13591409),D(1),D(6),D(13591409)\n for k in range(1,digits//14+10):\n  M=(M*(K**3-16*K))/(k**3)\n  L+=D(545140134)\n  X*=D(-262537412640768000)\n  S+=M*L/X\n  K+=D(12)\n return +C/S\ndef main():\n digits=1000\n pi=compute_pi(digits)\n tau=pi*D(2)\n s=format(tau,'f')\n intp,fracp=s.split('.')\n fracp=(fracp+'0'*digits)[:digits]\n print(f\"{intp}.{fracp}\")\nif __name__=='__main__':main()"
  },
  {
    "id": "φ",
    "description": "Print the first 1,000 decimal digits of the Golden ratio φ (phi).\nOEIS A001622,\nWikipedia\nCopy Answer\nCopied",
    "solution": "from decimal import Decimal, getcontext\n\ndef golden_ratio_digits(precision=1000):\n    \"\"\"\n    Calculates and prints the first 'precision' decimal digits of the Golden Ratio (phi).\n\n    Args:\n        precision (int): The number of decimal digits to calculate.  Defaults to 1000.\n    \"\"\"\n\n    getcontext().prec = precision + 10  # Add some extra precision to avoid rounding errors\n\n    phi = (Decimal(5).sqrt() + 1) / 2\n\n    phi_str = str(phi)\n\n    # Find the position of the decimal point\n    decimal_point_index = phi_str.find('.')\n\n    # Extract digits after the decimal point, plus the leading digit\n    digits = phi_str[:decimal_point_index + precision + 1]\n\n    print(digits)\n\n\nif __name__ == '__main__':\n    golden_ratio_digits(1000)"
  },
  {
    "id": "√2",
    "description": "Print the first 1,000 decimal digits of √2 (Pythagoras’ constant).\nOEIS A002193,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal as D,getcontext\ndef main():\n DIGITS=1000\n getcontext().prec=DIGITS+10\n two=D(2)\n root2=two.sqrt()\n s=format(root2,'f')\n int_part,frac_part=s.split('.')\n frac_part=(frac_part+'0'*DIGITS)[:DIGITS]\n print(f\"{int_part}.{frac_part}\")\nif __name__=='__main__':main()"
  },
  {
    "id": "e",
    "description": "Print the first 1,000 decimal digits of 𝑒 (Euler’s number).\nOEIS A001113,\nWikipedia\nCopy Answer\nCopied",
    "solution": "import decimal\nfrom decimal import Decimal as D,getcontext\ndef compute_e(digits):\n getcontext().prec=digits+20\n one,e_sum,term,k=D(1),D(1),D(1),1\n threshold=D(10)**(-(digits+5))\n while term>threshold:\n  term/=D(k)\n  e_sum+=term\n  k+=1\n return +e_sum\ndef main():\n DIGITS=1000\n e=compute_e(DIGITS)\n s=format(e,'f')\n intp,fracp=s.split('.')\n fracp=(fracp+'0'*DIGITS)[:DIGITS]\n print(f\"{intp}.{fracp}\")\nif __name__=='__main__':main()"
  }
]